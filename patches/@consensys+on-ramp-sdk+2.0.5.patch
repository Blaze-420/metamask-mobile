diff --git a/node_modules/@consensys/on-ramp-sdk/dist/NativeRampService.d.ts b/node_modules/@consensys/on-ramp-sdk/dist/NativeRampService.d.ts
new file mode 100644
index 0000000..89a81a2
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/NativeRampService.d.ts
@@ -0,0 +1,208 @@
+export interface NativeTransakAccessToken {
+    id: string;
+    ttl: number;
+    created: Date;
+    userId: string;
+}
+export interface NativeTransakUserDetails {
+    id: string;
+    firstName: string;
+    lastName: string;
+    email: string;
+    mobileNumber: string;
+    status: string;
+    dob: string;
+    kyc: NativeTransakUserDetailsKyc;
+    address: NativeTransakUserDetailsAddress;
+    createdAt: string;
+    isKycApproved: () => boolean;
+}
+export interface NativeTransakUserDetailsAddress {
+    addressLine1: string;
+    addressLine2: string;
+    state: string;
+    city: string;
+    postCode: string;
+    country: string;
+    countryCode: string;
+}
+export interface NativeTransakUserDetailsKyc {
+    l1: NativeTransakUserDetailsKycDetails;
+}
+export interface NativeTransakUserDetailsKycDetails {
+    status: string;
+    type: string;
+    updatedAt: string;
+    kycSubmittedAt: string;
+}
+export interface BuyQuote {
+    quoteId: string;
+    conversionPrice: number;
+    marketConversionPrice: number;
+    slippage: number;
+    fiatCurrency: string;
+    cryptoCurrency: string;
+    paymentMethod: string;
+    fiatAmount: number;
+    cryptoAmount: number;
+    isBuyOrSell: string;
+    network: string;
+    feeDecimal: number;
+    totalFee: number;
+    feeBreakdown: any[];
+    nonce: number;
+    cryptoLiquidityProvider: string;
+    notes: any[];
+}
+export interface KycForms {
+    forms: KycForm[];
+    onboardingSessionId: string;
+    kycType: string;
+    kycFlowType: string;
+    isAllowedToDoKyc: boolean;
+    isAllowedToPlaceOrder: boolean;
+}
+export interface KycForm {
+    id: string;
+    active: boolean;
+    hideProgress: boolean;
+    onSubmit: string;
+}
+export interface KycFormDetails {
+    formId: string;
+    formName: string;
+    endpoint: KycFormDetailsEndpoint;
+    hideProgress: boolean;
+    supportAutoSubmit: boolean;
+    fields: KycFormDetailsField[];
+    id: string;
+    type: string;
+    data: any;
+}
+export interface KycFormDetailsEndpoint {
+    path: string;
+    method: string;
+    excludeDisabled: boolean;
+}
+export interface KycFormDetailsField {
+    name: string;
+    id: string;
+    type: string;
+    value: string;
+    regex: string;
+    regexErrorMessage: string;
+    disabled: boolean;
+    isRequired: boolean;
+    placeholder: string;
+    cols: KycFormDetailsFieldCols;
+}
+export interface KycFormDetailsFieldCols {
+    xs: number;
+    md: number;
+    lg: number;
+}
+export interface Reservation {
+    id: string;
+}
+export interface BuyOrder {
+    id: string;
+    userId: string;
+    status: string;
+    isBuyOrSell: string;
+    fiatCurrency: string;
+    cryptoCurrency: string;
+    paymentOptionId: string;
+    network: string;
+    walletAddress: string;
+    addressAdditionalData: boolean;
+    quoteId: string;
+    fiatAmount: number;
+    fiatAmountInUsd: number;
+    amountPaid: number;
+    cryptoAmount: number;
+    conversionPrice: number;
+    totalFeeInFiat: number;
+    paymentOptions: OrderPaymentMethod[];
+    transactionHash: string;
+    createdAt: string;
+    updatedAt: string;
+    completedAt: string;
+    statusHistories: any[];
+}
+export interface OrderPaymentMethod {
+    currency: string;
+    id: string;
+    name: string;
+    fields: OrderPaymentMethodField[];
+}
+export interface OrderPaymentMethodField {
+    name: string;
+    id: string;
+    value: string;
+}
+export interface UserLimits {
+    response: {
+        data: {
+            isAllowed: boolean;
+            isKycRequired: boolean;
+            minFiatAmount: number;
+            maxFiatAmount: number;
+            limits: {
+                daily: {
+                    total: number;
+                    spent: number;
+                    remaining: number;
+                    exceeded: boolean;
+                };
+                monthly: {
+                    total: number;
+                    spent: number;
+                    remaining: number;
+                    exceeded: boolean;
+                };
+                yearly: {
+                    total: number;
+                    spent: number;
+                    remaining: number;
+                    exceeded: boolean;
+                };
+            };
+        };
+    };
+}
+export interface OttResponse {
+    token: string;
+}
+export interface OrdersList {
+    orders: BuyOrder[];
+}
+export declare enum TransakEnvironment {
+    Production = 0,
+    Staging = 1
+}
+export declare class NativeRampService {
+    private readonly partnerApiKey;
+    private readonly frontendAuth;
+    private transakAxios;
+    private environment;
+    constructor(environment: TransakEnvironment, partnerApiKey: string, frontendAuth: string);
+    sendUserOtp(email: string): Promise<{
+        isTncAccepted: boolean;
+    }>;
+    verifyUserOtp(email: string, verificationCode: string): Promise<NativeTransakAccessToken>;
+    getUserDetails(accessToken: NativeTransakAccessToken): Promise<NativeTransakUserDetails>;
+    getBuyQuote(fiatCurrency: string, cryptoCurrency: string, network: string, paymentMethod: string, fiatAmount: string): Promise<BuyQuote>;
+    getKYCForms(accessToken: NativeTransakAccessToken, quote: BuyQuote): Promise<KycForms>;
+    getKycForm(accessToken: NativeTransakAccessToken, quote: BuyQuote, form: KycForm): Promise<KycFormDetails>;
+    patchUser(accessToken: NativeTransakAccessToken, data: any): Promise<any>;
+    submitPurposeOfUsageForm(accessToken: NativeTransakAccessToken, purpose: string[]): Promise<void>;
+    walletReserve(quote: BuyQuote, walletAddress: string): Promise<Reservation>;
+    cancelOrder(accessToken: NativeTransakAccessToken, orderId: string): Promise<void>;
+    createOrder(accessToken: NativeTransakAccessToken, reservation: Reservation): Promise<BuyOrder>;
+    confirmPayment(accessToken: NativeTransakAccessToken, order: BuyOrder, paymentMethod: OrderPaymentMethod): Promise<any>;
+    getOrder(accessToken: NativeTransakAccessToken, orderId: string): Promise<BuyOrder>;
+    getUserLimits(accessToken: NativeTransakAccessToken, fiatCurrency: string, paymentMethod?: string, kycType?: string): Promise<UserLimits>;
+    requestOtt(accessToken: NativeTransakAccessToken): Promise<OttResponse>;
+    generatePaymentWidgetUrl(ottToken: string, fiatCurrency: string, cryptoCurrency: string, network: string, fiatAmount: string, walletAddress: string, paymentMethod: string, redirectUrl: string): string;
+    getRecentOrders(accessToken: NativeTransakAccessToken, limit?: number): Promise<OrdersList>;
+}
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/NativeRampService.js b/node_modules/@consensys/on-ramp-sdk/dist/NativeRampService.js
new file mode 100644
index 0000000..04510f2
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/NativeRampService.js
@@ -0,0 +1,317 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.NativeRampService = exports.TransakEnvironment = void 0;
+const axios_1 = __importDefault(require("axios"));
+var TransakEnvironment;
+(function (TransakEnvironment) {
+    TransakEnvironment[TransakEnvironment["Production"] = 0] = "Production";
+    TransakEnvironment[TransakEnvironment["Staging"] = 1] = "Staging";
+})(TransakEnvironment = exports.TransakEnvironment || (exports.TransakEnvironment = {}));
+class NativeRampService {
+    constructor(environment, partnerApiKey, frontendAuth) {
+        this.partnerApiKey = partnerApiKey;
+        this.frontendAuth = frontendAuth;
+        this.environment = environment;
+        const endpoint = environment === TransakEnvironment.Production
+            ? 'https://api.transak.com'
+            : 'https://api-stg.transak.com';
+        if (!endpoint) {
+            throw new Error('Invalid environment');
+        }
+        this.transakAxios = axios_1.default.create({
+            baseURL: endpoint,
+            headers: {},
+        });
+    }
+    async sendUserOtp(email) {
+        try {
+            return (await this.transakAxios.post('/api/v2/user/email/send', {
+                partnerApiKey: this.partnerApiKey,
+                email: email,
+            }, {
+                headers: {
+                    'frontend-auth': this.frontendAuth,
+                    'x-trace-id': '8e3dc027-e5e2-4765-99e6-6c3393d5d99f',
+                },
+            })).data.response;
+        }
+        catch (error) {
+            console.error('Error in sendUserOtp:', error);
+            throw error;
+        }
+    }
+    async verifyUserOtp(email, verificationCode) {
+        try {
+            return (await this.transakAxios.post('/api/v2/user/email/verify', {
+                partnerApiKey: this.partnerApiKey,
+                email: email,
+                emailVerificationCode: verificationCode,
+                isTncAccepted: true,
+            }, {
+                headers: {
+                    'frontend-auth': this.frontendAuth,
+                    'x-trace-id': '8e3dc027-e5e2-4765-99e6-6c3393d5d99f',
+                },
+            })).data.response;
+        }
+        catch (error) {
+            console.error('Error in verifyUserOtp:', error);
+            throw error;
+        }
+    }
+    async getUserDetails(accessToken) {
+        try {
+            const result = (await this.transakAxios.get('/api/v2/user', {
+                params: {
+                    apiKey: this.partnerApiKey,
+                },
+                headers: {
+                    authorization: accessToken.id,
+                    'x-trace-id': '8e3dc027-e5e2-4765-99e6-6c3393d5d99f',
+                },
+            })).data.response;
+            result.isKycApproved = () => result.kyc.l1.status === 'APPROVED';
+            return result;
+        }
+        catch (error) {
+            console.error('Error in getUserDetails:', error);
+            throw error;
+        }
+    }
+    async getBuyQuote(fiatCurrency, cryptoCurrency, network, paymentMethod, fiatAmount) {
+        try {
+            return (await this.transakAxios.get('/api/v1/pricing/public/quotes', {
+                params: {
+                    partnerApiKey: this.partnerApiKey,
+                    fiatCurrency: fiatCurrency,
+                    cryptoCurrency: cryptoCurrency,
+                    isBuyOrSell: 'BUY',
+                    network: network,
+                    paymentMethod: paymentMethod,
+                    fiatAmount: fiatAmount,
+                },
+                headers: {},
+            })).data.response;
+        }
+        catch (error) {
+            console.error('Error in getBuyQuote:', error);
+            throw error;
+        }
+    }
+    async getKYCForms(accessToken, quote) {
+        return (await this.transakAxios.get('/api/v2/user/kyc/get-forms', {
+            params: {
+                onlyFormIds: true,
+                'metadata[quoteId]': quote.quoteId,
+                'metadata[formType]': 'KYC',
+            },
+            headers: {
+                authorization: accessToken.id,
+            },
+        })).data.response;
+    }
+    async getKycForm(accessToken, quote, form) {
+        return (await this.transakAxios.get('/api/v2/user/kyc/get-forms', {
+            params: {
+                onlyFormIds: false,
+                'formIds[]': form.id,
+                'metadata[quoteId]': quote.quoteId,
+                'metadata[formType]': 'KYC',
+            },
+            headers: {
+                authorization: accessToken.id,
+            },
+        })).data.response;
+    }
+    async patchUser(accessToken, data) {
+        return (await this.transakAxios.patch('/api/v2/user', data, {
+            params: {
+                apiKey: this.partnerApiKey,
+            },
+            headers: {
+                authorization: accessToken.id,
+                'Content-Type': 'application/json',
+            },
+        })).data.response;
+    }
+    async submitPurposeOfUsageForm(accessToken, purpose) {
+        return (await this.transakAxios.post('/api/v2/user/purpose-of-usage', {
+            purposeList: purpose,
+        }, {
+            headers: {
+                authorization: accessToken.id,
+            },
+        })).data.response;
+    }
+    async walletReserve(quote, walletAddress) {
+        return (await this.transakAxios.post('/api/v2/orders/wallet-reserve', {
+            quoteId: quote.quoteId,
+            walletAddress: walletAddress,
+        }, {
+            headers: {},
+        })).data.response;
+    }
+    async cancelOrder(accessToken, orderId) {
+        var _a;
+        console.log(`[cancelOrder] Starting cancellation for order: ${orderId}`);
+        try {
+            await this.transakAxios.delete(`/api/v2/orders/${orderId}`, {
+                params: {
+                    cancelReason: 'Creating new order',
+                },
+                headers: {
+                    authorization: accessToken.id,
+                },
+            });
+            console.log(`[cancelOrder] Successfully cancelled order: ${orderId}`);
+        }
+        catch (error) {
+            console.error(`[cancelOrder] Error cancelling order:`, ((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) || error);
+            throw error;
+        }
+    }
+    async createOrder(accessToken, reservation) {
+        var _a, _b, _c, _d, _e, _f, _g, _h;
+        console.log(`[createOrder] Attempting to create order with reservation ID: ${reservation.id}`);
+        try {
+            const response = await this.transakAxios.post('/api/v2/orders', {
+                reservationId: reservation.id,
+            }, {
+                headers: {
+                    authorization: accessToken.id,
+                },
+            });
+            console.log(`[createOrder] Successfully created order: ${response.data.response.id}`);
+            return response.data.response;
+        }
+        catch (error) {
+            console.log(`[createOrder] Error encountered: ${((_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.message) || error.message}`);
+            if (((_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message) === 'Order exists') {
+                const existingOrder = error.response.data.error.details.data;
+                console.log(`[createOrder] Found existing order with ID: ${existingOrder.id}`);
+                console.log(`[createOrder] Existing order status: ${existingOrder.status}`);
+                try {
+                    console.log(`[createOrder] Attempting to cancel existing order: ${existingOrder.id}`);
+                    await this.cancelOrder(accessToken, existingOrder.id);
+                    console.log(`[createOrder] Successfully cancelled existing order`);
+                    console.log(`[createOrder] Waiting 2 seconds before retrying order creation...`);
+                    await new Promise((resolve) => setTimeout(resolve, 2000));
+                    console.log(`[createOrder] Retrying order creation with reservation ID: ${reservation.id}`);
+                    const retryResponse = await this.transakAxios.post('/api/v2/orders', {
+                        reservationId: reservation.id,
+                    }, {
+                        headers: {
+                            authorization: accessToken.id,
+                        },
+                    });
+                    console.log(`[createOrder] Successfully created new order after cancellation: ${retryResponse.data.response.id}`);
+                    return retryResponse.data.response;
+                }
+                catch (retryError) {
+                    console.error(`[createOrder] Error during order cancellation/retry process:`, ((_g = retryError === null || retryError === void 0 ? void 0 : retryError.response) === null || _g === void 0 ? void 0 : _g.data) || retryError);
+                    throw retryError;
+                }
+            }
+            console.error(`[createOrder] Unhandled error:`, ((_h = error === null || error === void 0 ? void 0 : error.response) === null || _h === void 0 ? void 0 : _h.data) || error);
+            throw error;
+        }
+    }
+    async confirmPayment(accessToken, order, paymentMethod) {
+        return (await this.transakAxios.post('/api/v2/orders/payment-confirmation', {
+            orderId: order.id,
+            paymentOptionId: paymentMethod.id,
+        }, {
+            headers: {
+                authorization: accessToken.id,
+            },
+        })).data.response;
+    }
+    async getOrder(accessToken, orderId) {
+        return (await this.transakAxios.get('/api/v2/orders/' + orderId, {
+            headers: {
+                authorization: accessToken.id,
+            },
+        })).data.response;
+    }
+    async getUserLimits(accessToken, fiatCurrency, paymentMethod = 'credit_debit_card', kycType = 'SIMPLE') {
+        try {
+            const response = await this.transakAxios.get('/api/v2/orders/order-limit', {
+                params: {
+                    isBuyOrSell: 'BUY',
+                    paymentCategory: paymentMethod,
+                    kycType: kycType,
+                    fiatCurrency: fiatCurrency,
+                },
+                headers: {
+                    authorization: accessToken.id,
+                },
+            });
+            return response.data || { response: {} };
+        }
+        catch (error) {
+            console.error('Error in getUserLimits:', error);
+            throw error;
+        }
+    }
+    async requestOtt(accessToken) {
+        try {
+            const response = await this.transakAxios.post('/auth/public/v1/request-ott', {
+                partnerApiKey: this.partnerApiKey,
+            }, {
+                headers: {
+                    authorization: `Bearer ${accessToken.id}`,
+                    'Content-Type': 'application/json',
+                },
+            });
+            if (!response.data) {
+                throw new Error('Failed to get OTT token');
+            }
+            return response.data.response;
+        }
+        catch (error) {
+            console.error('Error in requestOtt:', error);
+            throw error;
+        }
+    }
+    generatePaymentWidgetUrl(ottToken, fiatCurrency, cryptoCurrency, network, fiatAmount, walletAddress, paymentMethod = 'credit_debit_card', redirectUrl) {
+        const widgetBaseUrl = this.environment === TransakEnvironment.Production
+            ? 'https://global.transak.com'
+            : 'https://global-stg.transak.com';
+        const params = new URLSearchParams({
+            ott: ottToken,
+            apiKey: this.partnerApiKey,
+            fiatCurrency: fiatCurrency,
+            cryptoCurrencyCode: cryptoCurrency,
+            productsAvailed: 'BUY',
+            fiatAmount: fiatAmount,
+            network: network,
+            paymentMethod: paymentMethod,
+            hideExchangeScreen: 'true',
+            walletAddress: walletAddress,
+            disableWalletAddressForm: 'true',
+            redirectURL: redirectUrl,
+        });
+        return `${widgetBaseUrl}?${params.toString()}`;
+    }
+    async getRecentOrders(accessToken, limit = 10) {
+        try {
+            return (await this.transakAxios.get('/api/v2/orders', {
+                params: {
+                    skip: 0,
+                    limit: limit,
+                },
+                headers: {
+                    authorization: accessToken.id,
+                },
+            })).data.response;
+        }
+        catch (error) {
+            console.error('Error in getRecentOrders:', error);
+            throw error;
+        }
+    }
+}
+exports.NativeRampService = NativeRampService;
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/OnRampSdk.d.ts b/node_modules/@consensys/on-ramp-sdk/dist/OnRampSdk.d.ts
index c0680d1..38fa885 100644
--- a/node_modules/@consensys/on-ramp-sdk/dist/OnRampSdk.d.ts
+++ b/node_modules/@consensys/on-ramp-sdk/dist/OnRampSdk.d.ts
@@ -7,6 +7,7 @@ import EnvironmentDetails from './EnvironmentDetails';
 import ReportsService from './reports/ReportsService';
 import { SdkFunctionIntrospection, SdkParamIntrospection } from './SdkIntrospection';
 import ServicesSignatures from './ServicesSignatures';
+import { NativeRampService } from './NativeRampService';
 export declare class OnRampSdk {
     private readonly context;
     private locale;
@@ -17,6 +18,7 @@ export declare class OnRampSdk {
     private reportsService;
     private sdkIntrospection;
     sdkParameters: OnRampSdkParameters;
+    private nativeRampService;
     private regionsAxios;
     private ordersAxios;
     private reportsAxios;
@@ -38,4 +40,4 @@ export declare class OnRampSdk {
     setLocale(locale: string): void;
     getSignature(targetClass: Record<string, any>, method: (...args: any[]) => any): SdkFunctionIntrospection;
 }
-export { Payment, PaymentType, Country, CryptoCurrency, FiatCurrency, QuoteError, QuoteResponse, SellQuoteResponse, AllQuotesResponse, AllSellQuotesResponse, Environment, Context, RegionProvider, Provider, Order, OrdersService, RegionsService, ReportsService, Limits, OrderStatusEnum, State, ProviderBuyFeatureBrowserEnum, SdkFunctionIntrospection, SdkParamIntrospection, QuoteRequestType, ServicesSignatures, };
+export { Payment, PaymentType, Country, CryptoCurrency, FiatCurrency, QuoteError, QuoteResponse, SellQuoteResponse, AllQuotesResponse, AllSellQuotesResponse, Environment, Context, RegionProvider, Provider, Order, OrdersService, RegionsService, NativeRampService, ReportsService, Limits, OrderStatusEnum, State, ProviderBuyFeatureBrowserEnum, SdkFunctionIntrospection, SdkParamIntrospection, QuoteRequestType, ServicesSignatures, };
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/OnRampSdk.js b/node_modules/@consensys/on-ramp-sdk/dist/OnRampSdk.js
index 5cd0665..da629ab 100644
--- a/node_modules/@consensys/on-ramp-sdk/dist/OnRampSdk.js
+++ b/node_modules/@consensys/on-ramp-sdk/dist/OnRampSdk.js
@@ -15,7 +15,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.ServicesSignatures = exports.QuoteRequestType = exports.ProviderBuyFeatureBrowserEnum = exports.OrderStatusEnum = exports.ReportsService = exports.RegionsService = exports.OrdersService = exports.Context = exports.Environment = exports.PaymentType = exports.OnRampSdk = void 0;
+exports.ServicesSignatures = exports.QuoteRequestType = exports.ProviderBuyFeatureBrowserEnum = exports.OrderStatusEnum = exports.ReportsService = exports.NativeRampService = exports.RegionsService = exports.OrdersService = exports.Context = exports.Environment = exports.PaymentType = exports.OnRampSdk = void 0;
 const IOnRampSdk_1 = require("./IOnRampSdk");
 Object.defineProperty(exports, "Environment", { enumerable: true, get: function () { return IOnRampSdk_1.Environment; } });
 Object.defineProperty(exports, "Context", { enumerable: true, get: function () { return IOnRampSdk_1.Context; } });
@@ -38,6 +38,8 @@ const SdkIntrospection_1 = __importDefault(require("./SdkIntrospection"));
 const SdkParam_1 = __importDefault(require("./SdkParam"));
 const ServicesSignatures_1 = __importDefault(require("./ServicesSignatures"));
 exports.ServicesSignatures = ServicesSignatures_1.default;
+const NativeRampService_1 = require("./NativeRampService");
+Object.defineProperty(exports, "NativeRampService", { enumerable: true, get: function () { return NativeRampService_1.NativeRampService; } });
 const logger = new Logger_1.Logger();
 class OnRampSdk {
     static create(connectionUrl = 'http://localhost:3000', context, config = {}) {
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/ServicesSignatures.d.ts b/node_modules/@consensys/on-ramp-sdk/dist/ServicesSignatures.d.ts
index c6ce2ac..e0fe9e2 100644
--- a/node_modules/@consensys/on-ramp-sdk/dist/ServicesSignatures.d.ts
+++ b/node_modules/@consensys/on-ramp-sdk/dist/ServicesSignatures.d.ts
@@ -357,6 +357,50 @@ declare const _default: {
             }[];
         };
     };
+    NativeRampService: {
+        createAxios: {
+            parameters: any[];
+        };
+        tryAxios: {
+            parameters: any[];
+        };
+        sendUserOtp: {
+            parameters: any[];
+        };
+        verifyUserOtp: {
+            parameters: any[];
+        };
+        getUserDetails: {
+            parameters: any[];
+        };
+        getBuyQuote: {
+            parameters: any[];
+        };
+        getKYCForms: {
+            parameters: any[];
+        };
+        getKycForm: {
+            parameters: any[];
+        };
+        patchUser: {
+            parameters: any[];
+        };
+        submitPurposeOfUsageForm: {
+            parameters: any[];
+        };
+        walletReserve: {
+            parameters: any[];
+        };
+        createOrder: {
+            parameters: any[];
+        };
+        confirmPayment: {
+            parameters: any[];
+        };
+        getOrder: {
+            parameters: any[];
+        };
+    };
     ReportsService: {
         getProvider: {
             parameters: any[];
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/ServicesSignatures.js b/node_modules/@consensys/on-ramp-sdk/dist/ServicesSignatures.js
index b4d5df2..9e8fd54 100644
--- a/node_modules/@consensys/on-ramp-sdk/dist/ServicesSignatures.js
+++ b/node_modules/@consensys/on-ramp-sdk/dist/ServicesSignatures.js
@@ -801,6 +801,50 @@ exports.default = {
             ]
         }
     },
+    "NativeRampService": {
+        "createAxios": {
+            "parameters": []
+        },
+        "tryAxios": {
+            "parameters": []
+        },
+        "sendUserOtp": {
+            "parameters": []
+        },
+        "verifyUserOtp": {
+            "parameters": []
+        },
+        "getUserDetails": {
+            "parameters": []
+        },
+        "getBuyQuote": {
+            "parameters": []
+        },
+        "getKYCForms": {
+            "parameters": []
+        },
+        "getKycForm": {
+            "parameters": []
+        },
+        "patchUser": {
+            "parameters": []
+        },
+        "submitPurposeOfUsageForm": {
+            "parameters": []
+        },
+        "walletReserve": {
+            "parameters": []
+        },
+        "createOrder": {
+            "parameters": []
+        },
+        "confirmPayment": {
+            "parameters": []
+        },
+        "getOrder": {
+            "parameters": []
+        }
+    },
     "ReportsService": {
         "getProvider": {
             "parameters": []
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/providers/Generic/GenericProviderSDK.test.d.ts b/node_modules/@consensys/on-ramp-sdk/dist/providers/Generic/GenericProviderSDK.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/providers/Generic/GenericProviderSDK.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/providers/Generic/GenericProviderSDK.test.js b/node_modules/@consensys/on-ramp-sdk/dist/providers/Generic/GenericProviderSDK.test.js
new file mode 100644
index 0000000..c5da45e
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/providers/Generic/GenericProviderSDK.test.js
@@ -0,0 +1,385 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const GenericProviderSDK_1 = require("./GenericProviderSDK");
+const API_1 = require("../../API");
+const RegionsService_1 = require("../../regions/RegionsService");
+const createMockProvider = () => ({
+    provider: {
+        id: 'test-provider',
+        name: 'Test Provider',
+        logos: {
+            light: 'light-logo-url',
+            dark: 'dark-logo-url',
+            height: 100,
+            width: 100,
+        },
+        description: '',
+        hqAddress: '',
+        links: [],
+        environmentType: 'STAGING',
+        features: {
+            buy: {
+                enabled: true,
+                browser: API_1.ProviderBuyFeatureBrowserEnum.InAppOsBrowser,
+                redirection: API_1.ProviderBuyFeatureRedirectionEnum.HttpRedirection,
+                userAgent: '',
+                padCustomOrderId: false,
+                orderCustomIdRequired: false,
+                orderCustomId: '',
+                orderCustomIdPrefixes: [],
+                orderCustomIdExpiration: 0,
+                supportedByBackend: true,
+                orderCustomIdSeparator: '',
+            },
+            recurringBuy: {
+                enabled: false,
+            },
+            quotes: {
+                enabled: true,
+                supportedByBackend: true,
+            },
+        },
+    },
+    supportedFiatCurrencies: [
+        {
+            id: 'USD',
+            translation: 'USD',
+            limits: {
+                'credit-card': {
+                    minAmount: 10,
+                    maxAmount: 1000,
+                    feeDynamicRate: 0,
+                    feeFixedRate: 0,
+                },
+            },
+            excludedPaymentMethods: [],
+        },
+    ],
+    supportedCryptoCurrencies: [
+        {
+            id: 'BTC',
+            translation: 'BTC',
+            specificNetworkId: '',
+            excludedFiat: [],
+            excludedFiatAndPaymentMethods: [],
+            limits: {
+                minAmount: 5,
+                maxAmount: 2000,
+                feeDynamicRate: 0,
+                feeFixedRate: 0,
+                payments: [
+                    {
+                        payment: 'credit-card',
+                        minAmount: 15,
+                        maxAmount: 500,
+                        feeDynamicRate: 0,
+                        feeFixedRate: 0,
+                    },
+                ],
+            },
+        },
+    ],
+    data: {},
+    supportedPaymentMethods: [],
+    quote: '',
+    sellQuote: '',
+    quoteTransformation: undefined,
+    sellQuoteTransformation: undefined,
+});
+const createMockQuoteOrQuery = (overrides = {}) => (Object.assign({ url: '', method: '', headers: {}, provider: 'mockProviderWithTransform', nativeApplePay: { supported: false, merchantId: '' }, metadata: {
+        tags: {
+            isBestRate: true,
+            isMostReliable: false,
+        },
+        reliability: 1,
+    }, quote: {
+        cryptoId: 'BTC',
+        fiatId: 'USD',
+        status: 1,
+        message: '',
+        error: null,
+        bestRate: true,
+        isCustomAction: false,
+        extraFee: 0,
+        crypto: {
+            id: 'BTC',
+            name: 'Bitcoin',
+            decimals: 8,
+            symbol: 'BTC',
+            idv2: 'BTC',
+            legacyId: 'BTC',
+            network: {
+                active: true,
+                chainName: 'Bitcoin',
+                shortName: 'BTC',
+                chainId: '1',
+            },
+            logo: '',
+            address: '',
+            limits: [],
+            sellEnabled: true,
+            assetId: '',
+        },
+        fiat: {
+            id: 'USD',
+            name: 'US Dollar',
+            symbol: '$',
+            decimals: 2,
+            denomSymbol: 'USD',
+        },
+        networkFee: 1,
+        providerFee: 2,
+        amountIn: 100,
+        amountOut: 0.5,
+        paymentMethod: { type: 'credit-card' },
+        receiver: 'wallet123',
+    } }, overrides));
+describe('GenericProviderSDK', () => {
+    let sdk;
+    let mockOnRampSdk;
+    let mockLogger;
+    let mockProvider;
+    beforeEach(() => {
+        mockLogger = {
+            log: jest.fn(),
+        };
+        mockOnRampSdk = {
+            sdkParameters: {
+                environment: {
+                    orders: 'https://api.test.com/',
+                },
+            },
+            getQuote: jest.fn(),
+            regions: jest.fn(),
+            orders: jest.fn(),
+        };
+        mockProvider = createMockProvider();
+        sdk = new GenericProviderSDK_1.GenericProviderSDK(mockOnRampSdk, 'test-provider', mockLogger);
+    });
+    describe('getId', () => {
+        it('should return provider id', () => {
+            expect(sdk.getId()).toBe('test-provider');
+        });
+    });
+    describe('getLimit', () => {
+        it('should return combined limits from fiat and crypto', async () => {
+            const result = await sdk.getLimit(mockProvider, 'USD', 'BTC', 'credit-card');
+            expect(result.minAmount).toBe(15);
+            expect(result.maxAmount).toBe(500);
+        });
+        it('should handle missing fiat limits', async () => {
+            const modifiedProvider = Object.assign(Object.assign({}, mockProvider), { supportedFiatCurrencies: [
+                    {
+                        id: 'USD',
+                        translation: 'USD',
+                        limits: {},
+                        excludedPaymentMethods: [],
+                    },
+                ] });
+            const result = await sdk.getLimit(modifiedProvider, 'USD', 'BTC', 'credit-card');
+            expect(result.minAmount).toBe(15);
+            expect(result.maxAmount).toBe(500);
+        });
+        it('should handle missing crypto limits', async () => {
+            const modifiedProvider = Object.assign(Object.assign({}, mockProvider), { supportedCryptoCurrencies: [
+                    {
+                        id: 'BTC',
+                        translation: 'BTC',
+                        limits: {
+                            minAmount: 0,
+                            maxAmount: 0,
+                            feeFixedRate: 0,
+                            feeDynamicRate: 0,
+                            payments: [],
+                        },
+                        excludedPaymentMethods: [],
+                        specificNetworkId: '',
+                        excludedFiat: [],
+                        excludedFiatAndPaymentMethods: [],
+                    },
+                ] });
+            const result = await sdk.getLimit(modifiedProvider, 'USD', 'BTC', 'credit-card');
+            expect(result.minAmount).toBe(10);
+            expect(result.maxAmount).toBe(1000);
+        });
+    });
+    describe('getSellLimit', () => {
+        it('should return sell limits for crypto', async () => {
+            const result = await sdk.getSellLimit(mockProvider, 'USD', 'BTC');
+            expect(result).toBeUndefined();
+        });
+    });
+    describe('formatQuote', () => {
+        it('should format buy quote correctly', async () => {
+            const mockProvider = createMockProvider();
+            const quoteOrQuery = createMockQuoteOrQuery();
+            const result = await sdk.formatQuote(quoteOrQuery, mockProvider, 'region1', 'credit-card', 'BTC', 'USD', 100, RegionsService_1.ProviderAction.buy, 'wallet123');
+            expect(result).toMatchObject({
+                provider: mockProvider.provider,
+                crypto: quoteOrQuery.quote.crypto,
+                cryptoId: 'BTC',
+                fiat: quoteOrQuery.quote.fiat,
+                fiatId: 'USD',
+                networkFee: 1,
+                providerFee: 2,
+                extraFee: 0,
+                amountIn: 100,
+                amountOut: 0.5,
+                tags: {
+                    isBestRate: true,
+                    isMostReliable: false,
+                },
+            });
+        });
+        it('should format sell quote correctly', async () => {
+            const quoteOrQuery = createMockQuoteOrQuery();
+            const result = await sdk.formatQuote(quoteOrQuery, mockProvider, 'region1', 'bank-transfer', 'BTC', 'USD', 0.5, RegionsService_1.ProviderAction.sell, 'account123');
+            expect(result).toMatchObject({
+                provider: mockProvider.provider,
+                crypto: quoteOrQuery.quote.crypto,
+                cryptoId: 'BTC',
+                fiat: quoteOrQuery.quote.fiat,
+                fiatId: 'USD',
+                networkFee: 1,
+                providerFee: 2,
+                extraFee: 0,
+                amountIn: 100,
+                amountOut: 0.5,
+                tags: {
+                    isBestRate: true,
+                    isMostReliable: false,
+                },
+            });
+        });
+        it('should handle missing metadata and tags', async () => {
+            const quoteOrQuery = createMockQuoteOrQuery();
+            const result = await sdk.formatQuote(quoteOrQuery, mockProvider, 'region1', 'credit-card', 'BTC', 'USD', 100, RegionsService_1.ProviderAction.buy, 'wallet123');
+            expect(result).toMatchObject({
+                provider: mockProvider.provider,
+                crypto: quoteOrQuery.quote.crypto,
+                cryptoId: 'BTC',
+                fiat: quoteOrQuery.quote.fiat,
+                fiatId: 'USD',
+                networkFee: 1,
+                providerFee: 2,
+                amountIn: 100,
+                amountOut: 0.5,
+                tags: {
+                    isBestRate: true,
+                    isMostReliable: false,
+                },
+            });
+        });
+        it('should handle quote transformation if provided', async () => {
+            const mockProviderWithTransform = Object.assign(Object.assign({}, mockProvider), { quoteTransformation: {
+                    amountIn: (amount) => amount * 2,
+                    amountOut: (amount) => amount / 2,
+                } });
+            const quoteOrQuery = createMockQuoteOrQuery();
+            const result = await sdk.formatQuote(quoteOrQuery, mockProviderWithTransform, 'region1', 'credit-card', 'BTC', 'USD', 100, RegionsService_1.ProviderAction.buy, 'wallet123');
+            if ('error' in result) {
+                fail('Expected QuoteResponse but got QuoteError');
+            }
+            else {
+                expect(result.amountIn).toBe(100);
+                expect(result.amountOut).toBe(0.5);
+            }
+        });
+        it('should handle quote with native Apple Pay', async () => {
+            const quoteOrQuery = createMockQuoteOrQuery({
+                nativeApplePay: { supported: true, merchantId: 'merchant123' },
+            });
+            const result = (await sdk.formatQuote(quoteOrQuery, mockProvider, 'region1', 'credit-card', 'BTC', 'USD', 100, RegionsService_1.ProviderAction.buy, 'wallet123'));
+            if ('error' in result) {
+                fail('Expected QuoteResponse but got QuoteError');
+            }
+            expect(result.isNativeApplePay).toBe(true);
+        });
+        it('should handle quote with custom action', async () => {
+            const quoteOrQuery = createMockQuoteOrQuery({
+                quote: Object.assign(Object.assign({}, createMockQuoteOrQuery().quote), { isCustomAction: true }),
+            });
+            const result = (await sdk.formatQuote(quoteOrQuery, mockProvider, 'region1', 'credit-card', 'BTC', 'USD', 100, RegionsService_1.ProviderAction.buy, 'wallet123'));
+            if ('error' in result) {
+                fail('Expected QuoteResponse but got QuoteError');
+            }
+            expect(result.isCustomAction).toBe(true);
+        });
+        it.skip('should handle quote error', async () => {
+            const quoteError = {
+                error: true,
+                status: 400,
+                message: 'Test error',
+                provider: mockProvider.provider,
+                canRetry: false,
+            };
+            const result = (await sdk.formatQuote(quoteError, mockProvider, 'region1', 'credit-card', 'BTC', 'USD', 100, RegionsService_1.ProviderAction.buy, 'wallet123'));
+            expect(result).toEqual(quoteError);
+        });
+    });
+    describe('getQuote', () => {
+        it.skip('should handle remote quote error', async () => {
+            mockOnRampSdk.getQuote.mockResolvedValue({
+                status: 400,
+                data: {
+                    error: {
+                        statusCode: 400,
+                        message: 'Bad Request',
+                    },
+                },
+                statusText: 'Bad Request',
+                headers: {},
+                config: {},
+            });
+            const result = await sdk.getQuote(mockProvider, 'quote-uri', 'region1', 'credit-card', 'BTC', 'USD', 100, 'wallet123');
+            expect(result).toHaveProperty('error', true);
+            expect(result).toHaveProperty('message', 'Bad Request');
+        });
+        it('should handle empty quote response', async () => {
+            mockOnRampSdk.getQuote.mockResolvedValue({
+                status: 200,
+                data: {},
+                statusText: 'OK',
+                headers: {},
+                config: {},
+            });
+            const result = await sdk.getQuote(mockProvider, 'quote-uri', 'region1', 'credit-card', 'BTC', 'USD', 100, 'wallet123');
+            expect(result).toHaveProperty('error', true);
+            expect(result).toHaveProperty('message', 'Unable to get quote from test-provider');
+        });
+    });
+    describe('getSellQuote', () => {
+        it('should handle successful sell quote', async () => {
+            mockOnRampSdk.getQuote.mockResolvedValue({
+                status: 200,
+                data: createMockQuoteOrQuery(),
+                statusText: 'OK',
+                headers: {},
+                config: {},
+            });
+            const result = await sdk.getSellQuote(mockProvider, 'quote-uri', 'region1', 'bank-transfer', 'BTC', 'USD', 0.5, 'account123');
+            if ('error' in result) {
+                fail('Expected SellQuoteResponse but got QuoteError');
+            }
+            expect(result.amountIn).toBe(100);
+            expect(result.amountOut).toBe(0.5);
+        });
+        it.skip('should handle sell quote error', async () => {
+            mockOnRampSdk.getQuote.mockResolvedValue({
+                status: 400,
+                data: {
+                    error: {
+                        statusCode: 400,
+                        message: 'Invalid sell amount',
+                    },
+                },
+                statusText: 'Bad Request',
+                headers: {},
+                config: {},
+            });
+            const result = await sdk.getSellQuote(mockProvider, 'quote-uri', 'region1', 'bank-transfer', 'BTC', 'USD', 0.5, 'account123');
+            expect(result).toHaveProperty('error', true);
+            expect(result).toHaveProperty('message', 'Invalid sell amount');
+        });
+    });
+});
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/providers/ProviderList.test.d.ts b/node_modules/@consensys/on-ramp-sdk/dist/providers/ProviderList.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/providers/ProviderList.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/providers/ProviderList.test.js b/node_modules/@consensys/on-ramp-sdk/dist/providers/ProviderList.test.js
new file mode 100644
index 0000000..056ba78
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/providers/ProviderList.test.js
@@ -0,0 +1,40 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const GenericProviderSDK_1 = require("./Generic/GenericProviderSDK");
+const ProviderList_1 = __importDefault(require("./ProviderList"));
+describe('ProviderList', () => {
+    let providerList;
+    let mockOnRampSdk;
+    let mockLogger;
+    let mockProvider;
+    beforeEach(() => {
+        mockOnRampSdk = {};
+        mockLogger = {};
+        mockProvider = {
+            getId: jest.fn().mockReturnValue('test-provider-id'),
+        };
+        providerList = new ProviderList_1.default(mockOnRampSdk, mockLogger);
+    });
+    describe('register', () => {
+        it('should register a provider correctly', () => {
+            providerList.register(mockProvider);
+            const provider = providerList.get('test-provider-id');
+            expect(provider).toBe(mockProvider);
+        });
+    });
+    describe('get', () => {
+        it('should return a registered provider', () => {
+            providerList.register(mockProvider);
+            const provider = providerList.get('test-provider-id');
+            expect(provider).toBe(mockProvider);
+        });
+        it('should return a GenericProviderSDK when provider is not registered', () => {
+            const nonExistentProviderId = 'non-existent-provider';
+            const provider = providerList.get(nonExistentProviderId);
+            expect(provider).toBeInstanceOf(GenericProviderSDK_1.GenericProviderSDK);
+        });
+    });
+});
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/regions/RegionsService.test.d.ts b/node_modules/@consensys/on-ramp-sdk/dist/regions/RegionsService.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/regions/RegionsService.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/regions/RegionsService.test.js b/node_modules/@consensys/on-ramp-sdk/dist/regions/RegionsService.test.js
new file mode 100644
index 0000000..dffbb71
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/regions/RegionsService.test.js
@@ -0,0 +1,578 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const RegionsService_1 = __importDefault(require("./RegionsService"));
+const Utils_1 = __importDefault(require("../Utils"));
+const CountryCache_1 = require("./CountryCache");
+describe('RegionsService', () => {
+    let consoleSpy;
+    let axiosMock;
+    let loggerMock;
+    let sdkMock;
+    let sdkParametersMock;
+    beforeEach(() => {
+        consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
+        axiosMock = {
+            get: jest.fn().mockResolvedValue({ data: [] }),
+        };
+        loggerMock = { log: jest.fn() };
+        sdkMock = {};
+        sdkParametersMock = {
+            environment: {
+                regions: 'http://example.com',
+                orders: 'http://example.com/orders',
+            },
+        };
+        jest.spyOn(Utils_1.default, 'downloadAsMap').mockResolvedValue(new Map());
+        RegionsService_1.default['instanceCount'] = 0;
+    });
+    afterEach(() => {
+        consoleSpy.mockRestore();
+        jest.restoreAllMocks();
+    });
+    describe('create method', () => {
+        it('should create an instance without warning when it is the first one', async () => {
+            const service = await RegionsService_1.default.create(axiosMock, loggerMock, sdkMock, sdkParametersMock);
+            expect(service).toBeInstanceOf(RegionsService_1.default);
+            expect(consoleSpy).not.toHaveBeenCalled();
+        });
+        it('should show warning when creating a second instance', async () => {
+            await RegionsService_1.default.create(axiosMock, loggerMock, sdkMock, sdkParametersMock);
+            await RegionsService_1.default.create(axiosMock, loggerMock, sdkMock, sdkParametersMock);
+            expect(consoleSpy).toHaveBeenCalledWith('1 other instance of the regions service already exists. The regions service is likely being used by multiple SDK instance. This might result in increased network activity and poor performance. If possible, OnRampSdk.getSdk().regions() should only be called once in your application or per webpage, as it contains cached data.');
+        });
+        it('should show plural warning when creating multiple instances', async () => {
+            await RegionsService_1.default.create(axiosMock, loggerMock, sdkMock, sdkParametersMock);
+            await RegionsService_1.default.create(axiosMock, loggerMock, sdkMock, sdkParametersMock);
+            await RegionsService_1.default.create(axiosMock, loggerMock, sdkMock, sdkParametersMock);
+            expect(consoleSpy).toHaveBeenLastCalledWith('2 other instances of the regions service already exist. The regions service is likely being used by multiple SDK instance. This might result in increased network activity and poor performance. If possible, OnRampSdk.getSdk().regions() should only be called once in your application or per webpage, as it contains cached data.');
+        });
+        it('should initialize the instance correctly', async () => {
+            const initSpy = jest.spyOn(RegionsService_1.default.prototype, 'init');
+            const service = await RegionsService_1.default.create(axiosMock, loggerMock, sdkMock, sdkParametersMock);
+            expect(service).toBeInstanceOf(RegionsService_1.default);
+            expect(initSpy).toHaveBeenCalledWith(sdkMock);
+            initSpy.mockRestore();
+        });
+    });
+    describe('service methods', () => {
+        let service;
+        beforeEach(async () => {
+            service = await RegionsService_1.default.create(axiosMock, loggerMock, sdkMock, sdkParametersMock);
+        });
+        describe('getCountries', () => {
+            it('should return cached countries if available', async () => {
+                const mockCountries = new Map([
+                    ['country1', { id: 'country1', name: 'Country 1' }],
+                    ['country2', { id: 'country2', name: 'Country 2' }],
+                ]);
+                jest.spyOn(Utils_1.default, 'downloadAsMap').mockResolvedValueOnce(mockCountries);
+                await service.reset(sdkMock);
+                const countries = await service.getCountries();
+                expect(countries).toHaveLength(2);
+                expect(countries[0].name).toBe('Country 1');
+            });
+            it('should download countries if cache is empty', async () => {
+                const mockCountries = new Map([
+                    ['country1', { id: 'country1', name: 'Country 1' }],
+                ]);
+                jest.spyOn(Utils_1.default, 'downloadAsMap').mockResolvedValueOnce(mockCountries);
+                const countries = await service.getCountries();
+                expect(countries).toHaveLength(1);
+                expect(countries[0].name).toBe('Country 1');
+            });
+        });
+        describe('getPaymentMethods', () => {
+            it('should return payment methods for a region', async () => {
+                const mockCache = {
+                    cachedPayments: [
+                        { id: 'payment1', buy: { enabled: true } },
+                        { id: 'payment2', buy: { enabled: false } },
+                    ],
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const payments = await service.getPaymentMethods('region1');
+                expect(payments).toHaveLength(1);
+                expect(payments[0].id).toBe('payment1');
+            });
+            it('should throw error if regionId is missing', async () => {
+                await expect(service.getPaymentMethods(undefined)).rejects.toThrow();
+            });
+        });
+        describe('getFiatCurrencies', () => {
+            it('should return fiat currencies for a region and payment method', async () => {
+                const mockCache = {
+                    cachedFiatCurrencies: new Map([
+                        [
+                            'fiat1',
+                            { fiatCurrency: { id: 'fiat1' }, excludedPaymentMethods: [] },
+                        ],
+                        [
+                            'fiat2',
+                            {
+                                fiatCurrency: { id: 'fiat2' },
+                                excludedPaymentMethods: ['payment1'],
+                            },
+                        ],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const fiats = await service.getFiatCurrencies('region1', 'payment1');
+                expect(fiats).toHaveLength(1);
+                expect(fiats[0].id).toBe('fiat1');
+            });
+        });
+        describe('getCryptoCurrencies', () => {
+            it('should return crypto currencies for given parameters', async () => {
+                const mockCache = {
+                    cachedPayments: [{ id: 'payment1' }],
+                    cachedFiatCurrencies: new Map([['fiat1', {}]]),
+                    cachedCryptoCurrencies: new Map([
+                        [
+                            'crypto1',
+                            {
+                                cryptoCurrency: { id: 'crypto1' },
+                                excludedPaymentMethods: [],
+                                excludedFiat: [],
+                                excludedFiatAndPaymentMethods: [],
+                            },
+                        ],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const cryptos = await service.getCryptoCurrencies('region1', 'payment1', 'fiat1');
+                expect(cryptos).toHaveLength(1);
+                expect(cryptos[0].id).toBe('crypto1');
+            });
+        });
+        describe('getParameters', () => {
+            it('should return region parameters', async () => {
+                const mockParameters = {
+                    disableLimits: false,
+                    defaultOrderCustomIdSeparator: '-',
+                };
+                const mockCache = {
+                    cachedParameters: mockParameters,
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const parameters = await service.getParameters('region1');
+                expect(parameters).toEqual(mockParameters);
+            });
+        });
+        describe('generateCustomOrderId', () => {
+            beforeEach(() => {
+                const mockCache = {
+                    cachedParameters: {
+                        defaultOrderCustomIdSeparator: '-',
+                    },
+                    cachedProviders: new Map(),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+            });
+            it('should generate custom order id with expiration', async () => {
+                const provider = {
+                    id: 'provider1',
+                    features: {
+                        buy: {
+                            orderCustomId: 'Digits10',
+                            orderCustomIdExpiration: 60,
+                        },
+                    },
+                };
+                const orderId = await service.generateCustomOrderId(provider, 'region1');
+                expect(orderId).toMatch(/provider1\/orders\/\d{10}-\d+/);
+            });
+            it('should generate custom order id without expiration', async () => {
+                const provider = {
+                    id: 'provider1',
+                    features: {
+                        buy: {
+                            orderCustomId: 'Digits10',
+                        },
+                    },
+                };
+                const orderId = await service.generateCustomOrderId(provider, 'region1');
+                expect(orderId).toMatch(/provider1\/orders\/\d{10}/);
+            });
+        });
+        describe('getSellCountries', () => {
+            it('should return only countries with sell support', async () => {
+                const mockCountries = new Map([
+                    [
+                        'country1',
+                        {
+                            id: 'country1',
+                            name: 'Country 1',
+                            support: { sell: true },
+                            states: [
+                                { id: 'state1', support: { sell: true } },
+                                { id: 'state2', support: { sell: false } },
+                            ],
+                        },
+                    ],
+                    [
+                        'country2',
+                        {
+                            id: 'country2',
+                            name: 'Country 2',
+                            support: { sell: false },
+                        },
+                    ],
+                ]);
+                jest.spyOn(Utils_1.default, 'downloadAsMap').mockResolvedValueOnce(mockCountries);
+                await service.reset(sdkMock);
+                const countries = await service.getSellCountries();
+                expect(countries).toHaveLength(1);
+                expect(countries[0].states).toHaveLength(1);
+                expect(countries[0].states[0].id).toBe('state1');
+            });
+        });
+        describe('getSellPaymentMethods', () => {
+            it('should return payment methods with sell enabled', async () => {
+                const mockCache = {
+                    cachedPayments: [
+                        { id: 'payment1', sell: { enabled: true } },
+                        { id: 'payment2', sell: { enabled: false } },
+                    ],
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const payments = await service.getSellPaymentMethods('region1');
+                expect(payments).toHaveLength(1);
+                expect(payments[0].id).toBe('payment1');
+            });
+        });
+        describe('getSellFiatCurrencies', () => {
+            it('should return fiat currencies for sell', async () => {
+                const mockCache = {
+                    cachedFiatCurrencies: new Map([
+                        [
+                            'fiat1',
+                            {
+                                fiatCurrency: { id: 'fiat1' },
+                                sell: {
+                                    enabled: true,
+                                    excludedPaymentMethods: [],
+                                },
+                            },
+                        ],
+                        [
+                            'fiat2',
+                            {
+                                fiatCurrency: { id: 'fiat2' },
+                                sell: {
+                                    enabled: true,
+                                    excludedPaymentMethods: ['payment1'],
+                                },
+                            },
+                        ],
+                        [
+                            'fiat3',
+                            {
+                                fiatCurrency: { id: 'fiat3' },
+                                sell: { enabled: false },
+                            },
+                        ],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const fiats = await service.getSellFiatCurrencies('region1', 'payment1');
+                expect(fiats).toHaveLength(1);
+                expect(fiats[0].id).toBe('fiat1');
+            });
+        });
+        describe('getSellCryptoCurrencies', () => {
+            it('should return crypto currencies for sell', async () => {
+                const mockCache = {
+                    cachedPayments: [{ id: 'payment1' }],
+                    cachedFiatCurrencies: new Map([['fiat1', {}]]),
+                    cachedCryptoCurrencies: new Map([
+                        [
+                            'crypto1',
+                            {
+                                cryptoCurrency: { id: 'crypto1' },
+                                sell: {
+                                    enabled: true,
+                                    excludedPaymentMethods: [],
+                                    excludedFiat: [],
+                                    excludedFiatAndPaymentMethods: [],
+                                },
+                            },
+                        ],
+                        [
+                            'crypto2',
+                            {
+                                cryptoCurrency: { id: 'crypto2' },
+                                sell: { enabled: false },
+                            },
+                        ],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const cryptos = await service.getSellCryptoCurrencies('region1', 'payment1', 'fiat1');
+                expect(cryptos).toHaveLength(1);
+                expect(cryptos[0].id).toBe('crypto1');
+            });
+        });
+        describe('getAllProviders', () => {
+            it('should return all providers for a region', async () => {
+                const mockCache = {
+                    cachedProviders: new Map([
+                        [
+                            'provider1',
+                            { provider: { id: 'provider1', name: 'Provider 1' } },
+                        ],
+                        [
+                            'provider2',
+                            { provider: { id: 'provider2', name: 'Provider 2' } },
+                        ],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const providers = await service.getAllProviders('region1');
+                expect(providers).toHaveLength(2);
+                expect(providers[0].id).toBe('provider1');
+            });
+        });
+        describe('getAllFiatCurrencies', () => {
+            it('should return all fiat currencies for a region', async () => {
+                const mockCache = {
+                    cachedFiatCurrencies: new Map([
+                        ['fiat1', { fiatCurrency: { id: 'fiat1', name: 'Fiat 1' } }],
+                        ['fiat2', { fiatCurrency: { id: 'fiat2', name: 'Fiat 2' } }],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const fiats = await service.getAllFiatCurrencies('region1');
+                expect(fiats).toHaveLength(2);
+                expect(fiats[0].id).toBe('fiat1');
+            });
+        });
+        describe('getAllCryptoCurrencies', () => {
+            it('should return all crypto currencies for a region', async () => {
+                const mockCache = {
+                    cachedCryptoCurrencies: new Map([
+                        [
+                            'crypto1',
+                            { cryptoCurrency: { id: 'crypto1', name: 'Crypto 1' } },
+                        ],
+                        [
+                            'crypto2',
+                            { cryptoCurrency: { id: 'crypto2', name: 'Crypto 2' } },
+                        ],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const cryptos = await service.getAllCryptoCurrencies('region1');
+                expect(cryptos).toHaveLength(2);
+                expect(cryptos[0].id).toBe('crypto1');
+            });
+        });
+        describe('getDefaultFiatCurrency', () => {
+            it('should return default fiat currency based on country settings', async () => {
+                const mockCountries = [
+                    {
+                        id: 'region1',
+                        currencies: ['/currencies/fiat/eur', '/currencies/fiat/usd'],
+                    },
+                ];
+                const mockFiats = [
+                    {
+                        fiatCurrency: { id: '/currencies/fiat/eur' },
+                        excludedPaymentMethods: [],
+                    },
+                ];
+                const result = service.getDefaultFiatCurrencySync(mockCountries, mockFiats, 'region1', 'payment1');
+                expect(result.id).toBe('/currencies/fiat/eur');
+            });
+            it('should fallback to USD if local currency not supported', async () => {
+                const mockCountries = [
+                    {
+                        id: 'region1',
+                        currencies: ['/currencies/fiat/local'],
+                    },
+                ];
+                const mockFiats = [
+                    {
+                        fiatCurrency: { id: '/currencies/fiat/usd' },
+                        excludedPaymentMethods: [],
+                    },
+                ];
+                const result = service.getDefaultFiatCurrencySync(mockCountries, mockFiats, 'region1', 'payment1');
+                expect(result.id).toBe('/currencies/fiat/usd');
+            });
+        });
+        describe('getCountryCache', () => {
+            it('should create new cache when not exists', async () => {
+                const mockCache = {
+                    expirationDate: new Date(Date.now() + 1000000),
+                    cachedParameters: {},
+                };
+                const createSpy = jest
+                    .spyOn(CountryCache_1.CountryCache, 'Create')
+                    .mockResolvedValue(mockCache);
+                await service['getCountryCache']('region1');
+                expect(createSpy).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), 'region1', undefined);
+            });
+            it('should reuse existing cache when not expired', async () => {
+                const mockCache = {
+                    expirationDate: new Date(Date.now() + 1000000),
+                    cachedParameters: {},
+                };
+                const createSpy = jest
+                    .spyOn(CountryCache_1.CountryCache, 'Create')
+                    .mockResolvedValue(mockCache);
+                await service['getCountryCache']('region1');
+                await service['getCountryCache']('region1');
+                expect(createSpy).toHaveBeenCalledTimes(1);
+            });
+            it('should refresh expired cache', async () => {
+                const expiredCache = {
+                    expirationDate: new Date(Date.now() - 1000000),
+                    cachedParameters: {},
+                };
+                const newCache = {
+                    expirationDate: new Date(Date.now() + 1000000),
+                    cachedParameters: {},
+                };
+                const createSpy = jest
+                    .spyOn(CountryCache_1.CountryCache, 'Create')
+                    .mockResolvedValueOnce(expiredCache)
+                    .mockResolvedValueOnce(newCache);
+                await service['getCountryCache']('region1');
+                await service['getCountryCache']('region1');
+                expect(createSpy).toHaveBeenCalledTimes(2);
+            });
+            it('should keep using expired cache if refresh fails', async () => {
+                const expiredCache = {
+                    expirationDate: new Date(Date.now() - 1000000),
+                    cachedParameters: {},
+                };
+                const createSpy = jest
+                    .spyOn(CountryCache_1.CountryCache, 'Create')
+                    .mockResolvedValue(expiredCache);
+                createSpy.mockClear();
+                const cache1 = await service['getCountryCache']('region1');
+                createSpy.mockRejectedValueOnce(new Error('Network error'));
+                const cache2 = await service['getCountryCache']('region1');
+                expect(cache1).toBe(cache2);
+                expect(createSpy).toHaveBeenCalledTimes(3);
+            });
+        });
+        describe('getProviderLimits', () => {
+            it('should return disabled limits when configured', async () => {
+                const mockCache = {
+                    cachedParameters: {
+                        disableLimits: true,
+                    },
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const limits = await service.getProviderLimits('region1', 'payment1', 'crypto1', 'fiat1', 'provider1');
+                expect(limits.minAmount).toBe(-Infinity);
+                expect(limits.maxAmount).toBe(Infinity);
+                expect(limits.quickAmounts).toEqual(expect.any(Array));
+            });
+            it('should get limits from provider SDK', async () => {
+                const mockCache = {
+                    cachedParameters: {
+                        disableLimits: false,
+                    },
+                    cachedProviders: new Map([
+                        ['provider1', { provider: { id: 'provider1' } }],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const mockProviderSdk = {
+                    getLimit: jest.fn().mockResolvedValue({
+                        minAmount: 100,
+                        maxAmount: 1000,
+                        feeDynamicRate: 0.01,
+                        feeFixedRate: 1,
+                    }),
+                };
+                service['providers'] = {
+                    get: jest.fn().mockReturnValue(mockProviderSdk),
+                };
+                const limits = await service.getProviderLimits('region1', 'payment1', 'crypto1', 'fiat1', 'provider1');
+                expect(limits.minAmount).toBe(100);
+                expect(limits.maxAmount).toBe(1000);
+                expect(mockProviderSdk.getLimit).toHaveBeenCalled();
+            });
+        });
+        describe('getLimits', () => {
+            it('should return disabled limits when configured', async () => {
+                const mockCache = {
+                    cachedParameters: {
+                        disableLimits: true,
+                    },
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const limits = await service.getLimits('region1', 'payment1', 'crypto1', 'fiat1');
+                expect(limits.minAmount).toBe(-Infinity);
+                expect(limits.maxAmount).toBe(Infinity);
+            });
+            it('should aggregate limits from all providers', async () => {
+                const mockCache = {
+                    cachedParameters: {
+                        disableLimits: false,
+                    },
+                    cachedProviders: new Map([
+                        [
+                            'provider1',
+                            {
+                                provider: { id: 'provider1' },
+                                supportedPaymentMethods: [{ id: 'payment1' }],
+                                supportedCryptoCurrencies: [
+                                    {
+                                        id: 'crypto1',
+                                        excludedFiat: [],
+                                        excludedFiatAndPaymentMethods: [],
+                                    },
+                                ],
+                                supportedFiatCurrencies: [
+                                    {
+                                        id: 'fiat1',
+                                        excludedPaymentMethods: [],
+                                    },
+                                ],
+                            },
+                        ],
+                    ]),
+                };
+                jest.spyOn(CountryCache_1.CountryCache, 'Create').mockResolvedValue(mockCache);
+                const mockProviderSdk = {
+                    getLimit: jest.fn().mockResolvedValue({
+                        minAmount: 100,
+                        maxAmount: 1000,
+                        feeDynamicRate: 0.01,
+                        feeFixedRate: 1,
+                    }),
+                };
+                service['providers'] = {
+                    get: jest.fn().mockReturnValue(mockProviderSdk),
+                };
+                const limits = await service.getLimits('region1', 'payment1', 'crypto1', 'fiat1');
+                expect(limits.minAmount).toBe(100);
+                expect(limits.maxAmount).toBe(1000);
+                expect(mockProviderSdk.getLimit).toHaveBeenCalled();
+            });
+        });
+        describe('getNetworkDetails', () => {
+            it('should return network details', async () => {
+                const mockNetworkDetails = [{ id: 'network1', name: 'Network 1' }];
+                axiosMock.get.mockResolvedValueOnce({ data: mockNetworkDetails });
+                const details = await service.getNetworkDetails();
+                expect(details).toEqual(mockNetworkDetails);
+                expect(axiosMock.get).toHaveBeenCalledWith('/regions/network-details');
+            });
+        });
+        describe('reset', () => {
+            it('should clear caches and reinitialize', async () => {
+                const initSpy = jest.spyOn(service, 'init');
+                await service.reset(sdkMock);
+                expect(initSpy).toHaveBeenCalledWith(sdkMock);
+            });
+        });
+    });
+});
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/reports/ReportsService.test.d.ts b/node_modules/@consensys/on-ramp-sdk/dist/reports/ReportsService.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/reports/ReportsService.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/@consensys/on-ramp-sdk/dist/reports/ReportsService.test.js b/node_modules/@consensys/on-ramp-sdk/dist/reports/ReportsService.test.js
new file mode 100644
index 0000000..b2c2424
--- /dev/null
+++ b/node_modules/@consensys/on-ramp-sdk/dist/reports/ReportsService.test.js
@@ -0,0 +1,368 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const ReportsService_1 = __importDefault(require("./ReportsService"));
+describe('ReportsService', () => {
+    let service;
+    let mockAxios;
+    let mockLogger;
+    let mockSdkParameters;
+    let mockRegionsService;
+    let mockBuildRegionsService;
+    beforeEach(() => {
+        mockAxios = {
+            get: jest.fn(),
+        };
+        mockLogger = {};
+        mockSdkParameters = {
+            environment: {
+                regions: 'https://test.com',
+            },
+        };
+        mockRegionsService = {
+            getCountries: jest.fn(),
+            getPaymentMethod: jest.fn(),
+            getFiatCurrency: jest.fn(),
+            getCryptoCurrency: jest.fn(),
+            getProvider: jest.fn(),
+            getFiatCurrencies: jest.fn(),
+            getCryptoCurrencies: jest.fn(),
+            getProvidersWithoutAmount: jest.fn(),
+            getProviders: jest.fn(),
+            getProviderLimits: jest.fn(),
+            getQuote: jest.fn(),
+        };
+        mockBuildRegionsService = jest.fn().mockResolvedValue(mockRegionsService);
+        service = new ReportsService_1.default(mockAxios, mockLogger, mockSdkParameters, mockBuildRegionsService);
+    });
+    describe('getProvider', () => {
+        it('should get provider details without providers parameter', async () => {
+            const mockResponse = {
+                data: {
+                    provider: {
+                        id: 'test-provider',
+                        logos: {},
+                    },
+                    supportedPayments: [{ payment: { id: 'card', logos: {} } }],
+                    declaredPayments: [{ payment: { id: 'bank', logos: {} } }],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getProvider('test-id');
+            expect(mockAxios.get).toHaveBeenCalledWith('/reportstest-id');
+            expect(result).toEqual(mockResponse.data);
+        });
+        it('should get provider details with providers parameter', async () => {
+            const providers = ['provider1', 'provider2'];
+            mockAxios.get.mockResolvedValue({ data: { provider: {} } });
+            await service.getProvider('test-id', providers);
+            expect(mockAxios.get).toHaveBeenCalledWith('/reportstest-id?providers=provider1,provider2');
+        });
+    });
+    describe('getProviders', () => {
+        it('should get all providers without providers parameter', async () => {
+            const mockResponse = {
+                data: {
+                    providers: [
+                        { provider: { id: 'provider1', logos: {} } },
+                        { provider: { id: 'provider2', logos: {} } },
+                    ],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getProviders();
+            expect(mockAxios.get).toHaveBeenCalledWith('/reports/providers');
+            expect(result).toEqual(mockResponse.data.providers);
+        });
+        it('should get providers with providers parameter', async () => {
+            const providers = ['provider1', 'provider2'];
+            mockAxios.get.mockResolvedValue({ data: { providers: [] } });
+            await service.getProviders(providers);
+            expect(mockAxios.get).toHaveBeenCalledWith('/reports/providers?providers=provider1,provider2');
+        });
+    });
+    describe('getQuote', () => {
+        const validParams = {
+            regionId: 'US',
+            paymentId: 'card',
+            fiatId: 'USD',
+            cryptoId: 'BTC',
+            amount: 100,
+            providerId: 'provider1',
+            receiver: '0x123',
+        };
+        beforeEach(() => {
+            mockRegionsService.getCountries.mockResolvedValue([
+                { id: 'US', support: { buy: true } },
+            ]);
+            mockRegionsService.getPaymentMethod.mockResolvedValue({ id: 'card' });
+            mockRegionsService.getFiatCurrency.mockResolvedValue({ id: 'USD' });
+            mockRegionsService.getCryptoCurrency.mockResolvedValue({ id: 'BTC' });
+            mockRegionsService.getProvider.mockResolvedValue({
+                provider: { id: 'provider1' },
+            });
+            mockRegionsService.getFiatCurrencies.mockResolvedValue([{ id: 'USD' }]);
+            mockRegionsService.getCryptoCurrencies.mockResolvedValue([{ id: 'BTC' }]);
+            mockRegionsService.getProvidersWithoutAmount.mockResolvedValue([
+                { id: 'provider1' },
+            ]);
+            mockRegionsService.getProviders.mockResolvedValue([{ id: 'provider1' }]);
+            mockRegionsService.getQuote.mockResolvedValue({ id: 'quote1' });
+        });
+        it('should return quote when all parameters are valid', async () => {
+            const result = await service.getQuote(validParams.regionId, validParams.paymentId, validParams.fiatId, validParams.cryptoId, validParams.amount, validParams.providerId, validParams.receiver);
+            expect(result).toEqual({ quote: { id: 'quote1' } });
+        });
+        it('should return error when region is not found', async () => {
+            mockRegionsService.getCountries.mockResolvedValue([]);
+            const result = await service.getQuote('INVALID', validParams.paymentId, validParams.fiatId, validParams.cryptoId, validParams.amount, validParams.providerId, validParams.receiver);
+            expect(result).toEqual({
+                errorMessage: 'This region could not be identified.',
+            });
+        });
+        it('should return error when country does not support buy', async () => {
+            mockRegionsService.getCountries.mockResolvedValue([
+                { id: 'US', support: { buy: false } },
+            ]);
+            const result = await service.getQuote(validParams.regionId, validParams.paymentId, validParams.fiatId, validParams.cryptoId, validParams.amount, validParams.providerId, validParams.receiver);
+            expect(result).toEqual({
+                errorMessage: 'This country is not supported.',
+            });
+        });
+    });
+    describe('getCountry', () => {
+        it('should get country details without providers parameter', async () => {
+            const mockResponse = {
+                data: {
+                    supportedProviders: [{ provider: { id: 'provider1', logos: {} } }],
+                    supportedPayments: [{ payment: { id: 'card', logos: {} } }],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getCountry('US');
+            expect(mockAxios.get).toHaveBeenCalledWith('/reportsUS');
+            expect(result).toEqual(mockResponse.data);
+        });
+        it('should get country details with providers parameter', async () => {
+            const providers = ['provider1', 'provider2'];
+            mockAxios.get.mockResolvedValue({ data: {} });
+            await service.getCountry('US', providers);
+            expect(mockAxios.get).toHaveBeenCalledWith('/reportsUS?providers=provider1,provider2');
+        });
+    });
+    describe('getCountries', () => {
+        it('should get all countries without providers parameter', async () => {
+            const mockResponse = {
+                data: {
+                    countries: [{ id: 'US' }, { id: 'UK' }],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getCountries();
+            expect(mockAxios.get).toHaveBeenCalledWith('/reports/regions/countries');
+            expect(result).toEqual(mockResponse.data.countries);
+        });
+    });
+    describe('getPayment', () => {
+        it('should get payment details', async () => {
+            const mockResponse = {
+                data: {
+                    payment: { id: 'card', logos: {} },
+                    supportedProviders: [{ provider: { id: 'provider1', logos: {} } }],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getPayment('card');
+            expect(mockAxios.get).toHaveBeenCalledWith('/reportscard');
+            expect(result).toEqual(mockResponse.data);
+        });
+    });
+    describe('getPayments', () => {
+        it('should get all payments', async () => {
+            const mockResponse = {
+                data: {
+                    payments: [
+                        { payment: { id: 'card', logos: {} } },
+                        { payment: { id: 'bank', logos: {} } },
+                    ],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getPayments();
+            expect(mockAxios.get).toHaveBeenCalledWith('/reports/payments');
+            expect(result).toEqual(mockResponse.data.payments);
+        });
+    });
+    describe('getCryptoCurrency', () => {
+        it('should get crypto currency details', async () => {
+            const mockResponse = {
+                data: {
+                    supportedProviders: [{ provider: { id: 'provider1', logos: {} } }],
+                    supportedPayments: [{ payment: { id: 'card', logos: {} } }],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getCryptoCurrency('BTC');
+            expect(mockAxios.get).toHaveBeenCalledWith('/reportsBTC');
+            expect(result).toEqual(mockResponse.data);
+        });
+    });
+    describe('getCryptoCurrencies', () => {
+        it('should get all crypto currencies', async () => {
+            const mockResponse = {
+                data: {
+                    cryptoCurrencies: [{ id: 'BTC' }, { id: 'ETH' }],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getCryptoCurrencies();
+            expect(mockAxios.get).toHaveBeenCalledWith('/reports/currencies/crypto');
+            expect(result).toEqual(mockResponse.data.cryptoCurrencies);
+        });
+    });
+    describe('getFiatCurrency', () => {
+        it('should get fiat currency details', async () => {
+            const mockResponse = {
+                data: {
+                    supportedProviders: [{ provider: { id: 'provider1', logos: {} } }],
+                    supportedPayments: [{ payment: { id: 'card', logos: {} } }],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getFiatCurrency('USD');
+            expect(mockAxios.get).toHaveBeenCalledWith('/reportsUSD');
+            expect(result).toEqual(mockResponse.data);
+        });
+    });
+    describe('getFiatCurrencies', () => {
+        it('should get all fiat currencies', async () => {
+            const mockResponse = {
+                data: {
+                    fiatCurrencies: [{ id: 'USD' }, { id: 'EUR' }],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getFiatCurrencies();
+            expect(mockAxios.get).toHaveBeenCalledWith('/reports/currencies/fiat');
+            expect(result).toEqual(mockResponse.data.fiatCurrencies);
+        });
+    });
+    describe('getSystem', () => {
+        it('should get system report', async () => {
+            const mockResponse = {
+                data: {
+                    ambiguousCryptoCurrencies: [
+                        {
+                            providers: [{ provider: { id: 'provider1', logos: {} } }],
+                        },
+                    ],
+                },
+            };
+            mockAxios.get.mockResolvedValue(mockResponse);
+            const result = await service.getSystem();
+            expect(mockAxios.get).toHaveBeenCalledWith('/reports/system');
+            expect(result).toEqual(mockResponse.data);
+        });
+    });
+    describe('getQuote additional tests', () => {
+        const validParams = {
+            regionId: 'US',
+            paymentId: 'card',
+            fiatId: 'USD',
+            cryptoId: 'BTC',
+            amount: 100,
+            providerId: 'valid-provider',
+            receiver: '0x123',
+        };
+        beforeEach(() => {
+            mockRegionsService.getCountries.mockResolvedValue([
+                { id: 'US', support: { buy: true } },
+            ]);
+        });
+        it('should return error when payment method is not supported', async () => {
+            mockRegionsService.getPaymentMethod.mockResolvedValue(undefined);
+            const result = await service.getQuote(validParams.regionId, 'invalid-payment', validParams.fiatId, validParams.cryptoId, validParams.amount, validParams.providerId, validParams.receiver);
+            expect(result.errorMessage).toContain('payment method is not supported');
+        });
+        it('should return error when fiat currency is not supported', async () => {
+            mockRegionsService.getPaymentMethod.mockResolvedValue({
+                id: 'valid-payment',
+                name: 'Valid Payment',
+            });
+            mockRegionsService.getFiatCurrency.mockResolvedValue(null);
+            const result = await service.getQuote(validParams.regionId, validParams.paymentId, 'INVALID', validParams.cryptoId, validParams.amount, validParams.providerId, validParams.receiver);
+            expect(result.errorMessage).toContain('fiat currency is not supported');
+        });
+        it('should return error when crypto currency is not supported', async () => {
+            mockRegionsService.getPaymentMethod.mockResolvedValue({
+                id: 'valid-payment',
+                name: 'Valid Payment',
+            });
+            mockRegionsService.getFiatCurrency.mockResolvedValue({
+                id: 'valid-fiat',
+                name: 'Valid Fiat',
+            });
+            mockRegionsService.getCryptoCurrency.mockResolvedValue(null);
+            const result = await service.getQuote(validParams.regionId, validParams.paymentId, validParams.fiatId, 'INVALID', validParams.amount, validParams.providerId, validParams.receiver);
+            expect(result.errorMessage).toContain('crypto currency is not supported');
+        });
+        it('should return error when provider is not supported', async () => {
+            mockRegionsService.getPaymentMethod.mockResolvedValue({
+                id: 'valid-payment',
+                name: 'Valid Payment',
+            });
+            mockRegionsService.getFiatCurrency.mockResolvedValue({
+                id: 'valid-fiat',
+                name: 'Valid Fiat',
+            });
+            mockRegionsService.getCryptoCurrency.mockResolvedValue({
+                id: 'valid-crypto',
+                name: 'Valid Crypto',
+            });
+            mockRegionsService.getProvider.mockResolvedValue(null);
+            const result = await service.getQuote(validParams.regionId, validParams.paymentId, validParams.fiatId, validParams.cryptoId, validParams.amount, validParams.providerId, validParams.receiver);
+            expect(result.errorMessage).toContain('provider is not supported');
+        });
+        it.skip('should return error when amount is outside limits', async () => {
+            mockRegionsService.getPaymentMethod.mockResolvedValue({
+                id: 'valid-payment',
+                name: 'Valid Payment',
+            });
+            mockRegionsService.getFiatCurrency.mockResolvedValue({
+                id: 'valid-fiat',
+                name: 'Valid Fiat',
+            });
+            mockRegionsService.getCryptoCurrency.mockResolvedValue({
+                id: 'valid-crypto',
+                name: 'Valid Crypto',
+            });
+            mockRegionsService.getProvider.mockResolvedValue({
+                id: 'valid-provider',
+                provider: 'valid-provider',
+                name: 'Valid Provider',
+            });
+            mockRegionsService.getProviders.mockResolvedValue([
+                'Provider1',
+                'Provider2',
+            ]);
+            mockRegionsService.getProviderLimits.mockResolvedValue({
+                minAmount: 50,
+                maxAmount: 1000,
+            });
+            const result = await service.getQuote(validParams.regionId, validParams.paymentId, validParams.fiatId, validParams.cryptoId, 10, validParams.providerId, validParams.receiver);
+            expect(result.errorMessage).toContain('amount between');
+        });
+        it('should handle state support', async () => {
+            mockRegionsService.getCountries.mockResolvedValue([
+                {
+                    id: 'US',
+                    states: [{ id: 'US-NY', support: { buy: false } }],
+                },
+            ]);
+            const result = await service.getQuote('US-NY', validParams.paymentId, validParams.fiatId, validParams.cryptoId, validParams.amount, validParams.providerId, validParams.receiver);
+            expect(result.errorMessage).toBe('This state is not supported.');
+        });
+    });
+});
