diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.cjs b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.cjs
index aba5594..f3fc0ef 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.cjs
@@ -125,42 +125,50 @@ class AccountTrackerController extends (0, polling_controller_1.StaticIntervalPo
      * @param networkClientId - Optional networkClientId to fetch a network client with
      */
     async refresh(networkClientId) {
-        const selectedAccount = this.messagingSystem.call('AccountsController:getSelectedAccount');
-        const releaseLock = await __classPrivateFieldGet(this, _AccountTrackerController_refreshMutex, "f").acquire();
-        try {
-            const { chainId, ethQuery } = __classPrivateFieldGet(this, _AccountTrackerController_instances, "m", _AccountTrackerController_getCorrectNetworkClient).call(this, networkClientId);
-            this.syncAccounts(chainId);
-            const { accountsByChainId } = this.state;
-            const { isMultiAccountBalancesEnabled } = this.messagingSystem.call('PreferencesController:getState');
-            const accountsToUpdate = isMultiAccountBalancesEnabled
-                ? Object.keys(accountsByChainId[chainId])
-                : [(0, controller_utils_1.toChecksumHexAddress)(selectedAccount.address)];
-            const accountsForChain = { ...accountsByChainId[chainId] };
-            for (const address of accountsToUpdate) {
-                const balance = await __classPrivateFieldGet(this, _AccountTrackerController_instances, "m", _AccountTrackerController_getBalanceFromChain).call(this, address, ethQuery);
-                if (balance) {
-                    accountsForChain[address] = {
-                        balance,
-                    };
-                }
-                if (__classPrivateFieldGet(this, _AccountTrackerController_includeStakedAssets, "f")) {
-                    const stakedBalance = await __classPrivateFieldGet(this, _AccountTrackerController_getStakedBalanceForChain, "f").call(this, address, networkClientId);
-                    if (stakedBalance) {
-                        accountsForChain[address] = {
-                            ...accountsForChain[address],
-                            stakedBalance,
-                        };
-                    }
-                }
-            }
-            this.update((state) => {
-                state.accountsByChainId[chainId] = accountsForChain;
-            });
-        }
-        finally {
-            releaseLock();
-        }
-    }
+      const selectedAccount = this.messagingSystem.call('AccountsController:getSelectedAccount');
+      const releaseLock = await __classPrivateFieldGet(this, _AccountTrackerController_refreshMutex, "f").acquire();
+      try {
+          const { chainId, ethQuery } = __classPrivateFieldGet(this, _AccountTrackerController_instances, "m", _AccountTrackerController_getCorrectNetworkClient).call(this, networkClientId);
+          this.syncAccounts(chainId);
+          const { accountsByChainId } = this.state;
+          const { isMultiAccountBalancesEnabled } = this.messagingSystem.call('PreferencesController:getState');
+          const accountsToUpdate = isMultiAccountBalancesEnabled
+              ? Object.keys(accountsByChainId[chainId])
+              : [(0, controller_utils_1.toChecksumHexAddress)(selectedAccount.address)];
+          const accountsForChain = { ...accountsByChainId[chainId] };
+          // Use Promise.allSettled to handle multiple asynchronous operations concurrently
+          const balancePromises = accountsToUpdate.map(async (address) => {
+              const balancePromise = __classPrivateFieldGet(this, _AccountTrackerController_instances, "m", _AccountTrackerController_getBalanceFromChain).call(this, address, ethQuery);
+              const stakedBalancePromise = __classPrivateFieldGet(this, _AccountTrackerController_includeStakedAssets, "f")
+                  ? __classPrivateFieldGet(this, _AccountTrackerController_getStakedBalanceForChain, "f").call(this, address, networkClientId)
+                  : Promise.resolve(null);
+              const [balanceResult, stakedBalanceResult] = await Promise.allSettled([
+                  balancePromise,
+                  stakedBalancePromise,
+              ]);
+              if (balanceResult.status === 'fulfilled' && balanceResult.value) {
+                  accountsForChain[address] = {
+                      balance: balanceResult.value,
+                  };
+              }
+              if (stakedBalanceResult.status === 'fulfilled' &&
+                  stakedBalanceResult.value) {
+                  accountsForChain[address] = {
+                      ...accountsForChain[address],
+                      stakedBalance: stakedBalanceResult.value,
+                  };
+              }
+          });
+          // Wait for all promises to settle
+          await Promise.allSettled(balancePromises);
+          this.update((state) => {
+              state.accountsByChainId[chainId] = accountsForChain;
+          });
+      }
+      finally {
+          releaseLock();
+      }
+  }
     /**
      * Sync accounts balances with some additional addresses.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.cjs b/node_modules/@metamask/assets-controllers/dist/NftController.cjs
index 0f15eb6..96e5a68 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.cjs
@@ -13,7 +13,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _NftController_instances, _NftController_mutex, _NftController_selectedAccountId, _NftController_chainId, _NftController_ipfsGateway, _NftController_openSeaEnabled, _NftController_useIpfsSubdomains, _NftController_isIpfsGatewayEnabled, _NftController_onNftAdded, _NftController_onNetworkControllerNetworkDidChange, _NftController_onPreferencesControllerStateChange, _NftController_onSelectedAccountChange, _NftController_updateNestedNftState, _NftController_getNftCollectionApi, _NftController_getNftInformationFromApi, _NftController_getNftInformationFromTokenURI, _NftController_getNftURIAndStandard, _NftController_getNftInformation, _NftController_getNftContractInformationFromContract, _NftController_getNftContractInformation, _NftController_addIndividualNft, _NftController_addNftContract, _NftController_removeAndIgnoreIndividualNft, _NftController_removeIndividualNft, _NftController_removeNftContract, _NftController_validateWatchNft, _NftController_getCorrectChainId, _NftController_getAddressOrSelectedAddress, _NftController_updateNftUpdateForAccount;
+var _NftController_instances, _NftController_mutex, _NftController_selectedAccountId, _NftController_chainId, _NftController_ipfsGateway, _NftController_displayNftMedia, _NftController_useIpfsSubdomains, _NftController_isIpfsGatewayEnabled, _NftController_onNftAdded, _NftController_onNetworkControllerNetworkDidChange, _NftController_onPreferencesControllerStateChange, _NftController_onSelectedAccountChange, _NftController_updateNestedNftState, _NftController_getNftCollectionApi, _NftController_getNftInformationFromApi, _NftController_getNftInformationFromTokenURI, _NftController_getNftURIAndStandard, _NftController_getNftInformation, _NftController_getNftContractInformationFromContract, _NftController_getNftContractInformation, _NftController_addIndividualNft, _NftController_addNftContract, _NftController_removeAndIgnoreIndividualNft, _NftController_removeIndividualNft, _NftController_removeNftContract, _NftController_validateWatchNft, _NftController_getCorrectChainId, _NftController_getAddressOrSelectedAddress, _NftController_updateNftUpdateForAccount;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.NftController = exports.getDefaultNftControllerState = void 0;
 const address_1 = require("@ethersproject/address");
@@ -54,7 +54,7 @@ class NftController extends base_controller_1.BaseController {
      * @param options - The controller options.
      * @param options.chainId - The chain ID of the current network.
      * @param options.ipfsGateway - The configured IPFS gateway.
-     * @param options.openSeaEnabled - Controls whether the OpenSea API is used.
+     * @param options.displayNftMedia - Controls whether the OpenSea API is used.
      * @param options.useIpfsSubdomains - Controls whether IPFS subdomains are used.
      * @param options.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
      * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
@@ -62,7 +62,7 @@ class NftController extends base_controller_1.BaseController {
      * @param options.messenger - The messenger.
      * @param options.state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, ipfsGateway = controller_utils_1.IPFS_DEFAULT_GATEWAY_URL, openSeaEnabled = false, useIpfsSubdomains = true, isIpfsGatewayEnabled = true, onNftAdded, messenger, state = {}, }) {
+    constructor({ chainId: initialChainId, ipfsGateway = controller_utils_1.IPFS_DEFAULT_GATEWAY_URL, displayNftMedia = false, useIpfsSubdomains = true, isIpfsGatewayEnabled = true, onNftAdded, messenger, state = {}, }) {
         super({
             name: controllerName,
             metadata: nftControllerMetadata,
@@ -77,14 +77,14 @@ class NftController extends base_controller_1.BaseController {
         _NftController_selectedAccountId.set(this, void 0);
         _NftController_chainId.set(this, void 0);
         _NftController_ipfsGateway.set(this, void 0);
-        _NftController_openSeaEnabled.set(this, void 0);
+        _NftController_displayNftMedia.set(this, void 0);
         _NftController_useIpfsSubdomains.set(this, void 0);
         _NftController_isIpfsGatewayEnabled.set(this, void 0);
         _NftController_onNftAdded.set(this, void 0);
         __classPrivateFieldSet(this, _NftController_selectedAccountId, this.messagingSystem.call('AccountsController:getSelectedAccount').id, "f");
         __classPrivateFieldSet(this, _NftController_chainId, initialChainId, "f");
         __classPrivateFieldSet(this, _NftController_ipfsGateway, ipfsGateway, "f");
-        __classPrivateFieldSet(this, _NftController_openSeaEnabled, openSeaEnabled, "f");
+        __classPrivateFieldSet(this, _NftController_displayNftMedia, displayNftMedia, "f");
         __classPrivateFieldSet(this, _NftController_useIpfsSubdomains, useIpfsSubdomains, "f");
         __classPrivateFieldSet(this, _NftController_isIpfsGatewayEnabled, isIpfsGatewayEnabled, "f");
         __classPrivateFieldSet(this, _NftController_onNftAdded, onNftAdded, "f");
@@ -597,7 +597,7 @@ class NftController extends base_controller_1.BaseController {
     }
 }
 exports.NftController = NftController;
-_NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new WeakMap(), _NftController_chainId = new WeakMap(), _NftController_ipfsGateway = new WeakMap(), _NftController_openSeaEnabled = new WeakMap(), _NftController_useIpfsSubdomains = new WeakMap(), _NftController_isIpfsGatewayEnabled = new WeakMap(), _NftController_onNftAdded = new WeakMap(), _NftController_instances = new WeakSet(), _NftController_onNetworkControllerNetworkDidChange = function _NftController_onNetworkControllerNetworkDidChange({ selectedNetworkClientId, }) {
+_NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new WeakMap(), _NftController_chainId = new WeakMap(), _NftController_ipfsGateway = new WeakMap(), _NftController_displayNftMedia = new WeakMap(), _NftController_useIpfsSubdomains = new WeakMap(), _NftController_isIpfsGatewayEnabled = new WeakMap(), _NftController_onNftAdded = new WeakMap(), _NftController_instances = new WeakSet(), _NftController_onNetworkControllerNetworkDidChange = function _NftController_onNetworkControllerNetworkDidChange({ selectedNetworkClientId, }) {
     const { configuration: { chainId }, } = this.messagingSystem.call('NetworkController:getNetworkClientById', selectedNetworkClientId);
     __classPrivateFieldSet(this, _NftController_chainId, chainId, "f");
 }, _NftController_onPreferencesControllerStateChange = 
@@ -605,20 +605,20 @@ _NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new Wea
  * Handles the state change of the preference controller.
  * @param preferencesState - The new state of the preference controller.
  * @param preferencesState.ipfsGateway - The configured IPFS gateway.
- * @param preferencesState.openSeaEnabled - Controls whether the OpenSea API is used.
+ * @param preferencesState.displayNftMedia - Controls whether the OpenSea API is used.
  * @param preferencesState.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
  */
-async function _NftController_onPreferencesControllerStateChange({ ipfsGateway, openSeaEnabled, isIpfsGatewayEnabled, }) {
+async function _NftController_onPreferencesControllerStateChange({ ipfsGateway, displayNftMedia, isIpfsGatewayEnabled, }) {
     const selectedAccount = this.messagingSystem.call('AccountsController:getSelectedAccount');
     __classPrivateFieldSet(this, _NftController_selectedAccountId, selectedAccount.id, "f");
     // Get current state values
     if (__classPrivateFieldGet(this, _NftController_ipfsGateway, "f") !== ipfsGateway ||
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f") !== openSeaEnabled ||
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f") !== displayNftMedia ||
         __classPrivateFieldGet(this, _NftController_isIpfsGatewayEnabled, "f") !== isIpfsGatewayEnabled) {
         __classPrivateFieldSet(this, _NftController_ipfsGateway, ipfsGateway, "f");
-        __classPrivateFieldSet(this, _NftController_openSeaEnabled, openSeaEnabled, "f");
+        __classPrivateFieldSet(this, _NftController_displayNftMedia, displayNftMedia, "f");
         __classPrivateFieldSet(this, _NftController_isIpfsGatewayEnabled, isIpfsGatewayEnabled, "f");
-        const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;
+        const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || displayNftMedia;
         if (needsUpdateNftMetadata && selectedAccount) {
             await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_updateNftUpdateForAccount).call(this, selectedAccount);
         }
@@ -632,7 +632,7 @@ async function _NftController_onSelectedAccountChange(internalAccount) {
     const oldSelectedAccountId = __classPrivateFieldGet(this, _NftController_selectedAccountId, "f");
     __classPrivateFieldSet(this, _NftController_selectedAccountId, internalAccount.id, "f");
     const needsUpdateNftMetadata = ((__classPrivateFieldGet(this, _NftController_isIpfsGatewayEnabled, "f") && __classPrivateFieldGet(this, _NftController_ipfsGateway, "f") !== '') ||
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f")) &&
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f")) &&
         oldSelectedAccountId !== internalAccount.id;
     if (needsUpdateNftMetadata) {
         await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_updateNftUpdateForAccount).call(this, internalAccount);
@@ -707,6 +707,7 @@ async function _NftController_getNftInformationFromApi(contractAddress, tokenId)
             description: null,
             image: null,
             standard: null,
+            error: 'Opensea import error',
         };
     }
     // if we've reached this point, we have successfully fetched some data for nftInformation
@@ -749,9 +750,10 @@ async function _NftController_getNftInformationFromTokenURI(contractAddress, tok
             standard: standard || null,
             favorite: false,
             tokenURI: tokenURI ?? null,
+            error: 'URI import error',
         };
     }
-    const isDisplayNFTMediaToggleEnabled = __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f");
+    const isDisplayNFTMediaToggleEnabled = __classPrivateFieldGet(this, _NftController_displayNftMedia, "f");
     if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
         return {
             image: null,
@@ -760,6 +762,7 @@ async function _NftController_getNftInformationFromTokenURI(contractAddress, tok
             standard: standard || null,
             favorite: false,
             tokenURI: tokenURI ?? null,
+            error: 'URI import error',
         };
     }
     if (hasIpfsTokenURI) {
@@ -853,10 +856,21 @@ async function _NftController_getNftInformation(contractAddress, tokenId, networ
     });
     const [blockchainMetadata, nftApiMetadata] = await Promise.all([
         (0, controller_utils_1.safelyExecute)(() => __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftInformationFromTokenURI).call(this, contractAddress, tokenId, networkClientId)),
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f") && chainId === '0x1'
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f") && chainId === '0x1'
             ? (0, controller_utils_1.safelyExecute)(() => __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftInformationFromApi).call(this, contractAddress, tokenId))
             : undefined,
     ]);
+    if (blockchainMetadata?.error && nftApiMetadata?.error) {
+        return {
+            image: null,
+            name: null,
+            description: null,
+            standard: blockchainMetadata.standard ?? null,
+            favorite: false,
+            tokenURI: blockchainMetadata.tokenURI ?? null,
+            error: 'Both import failed',
+        };
+    }
     return {
         ...nftApiMetadata,
         name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
@@ -998,6 +1012,7 @@ async function _NftController_addIndividualNft(tokenAddress, tokenId, nftMetadat
                 tokenId: tokenId.toString(),
                 standard: nftMetadata.standard,
                 source,
+                tokenURI: nftMetadata.tokenURI
             });
         }
     }
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.cts b/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
index 4384784..e35e71c 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
@@ -108,6 +108,7 @@ export type NftMetadata = {
     creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
+    error?: string;
     collection?: Collection;
     address?: string;
     attributes?: Attributes[];
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.cjs b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.cjs
index 448fd39..f5859be 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.cjs
@@ -10,7 +10,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _TokenRatesController_instances, _TokenRatesController_handle, _TokenRatesController_pollState, _TokenRatesController_tokenPricesService, _TokenRatesController_inProcessExchangeRateUpdates, _TokenRatesController_selectedAccountId, _TokenRatesController_disabled, _TokenRatesController_chainId, _TokenRatesController_ticker, _TokenRatesController_interval, _TokenRatesController_allTokens, _TokenRatesController_allDetectedTokens, _TokenRatesController_subscribeToTokensStateChange, _TokenRatesController_subscribeToNetworkStateChange, _TokenRatesController_getTokenAddresses, _TokenRatesController_getSelectedAccount, _TokenRatesController_getChainIdAndTicker, _TokenRatesController_getTokensControllerState, _TokenRatesController_stopPoll, _TokenRatesController_poll, _TokenRatesController_fetchAndMapExchangeRates, _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency, _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency;
+var _TokenRatesController_instances, _TokenRatesController_handle, _TokenRatesController_pollState, _TokenRatesController_tokenPricesService, _TokenRatesController_inProcessExchangeRateUpdates, _TokenRatesController_disabled, _TokenRatesController_interval, _TokenRatesController_allTokens, _TokenRatesController_allDetectedTokens, _TokenRatesController_subscribeToTokensStateChange, _TokenRatesController_subscribeToNetworkStateChange, _TokenRatesController_getTokenAddresses, _TokenRatesController_getTokensControllerState, _TokenRatesController_stopPoll, _TokenRatesController_poll, _TokenRatesController_fetchAndMapExchangeRates, _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency, _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenRatesController = exports.getDefaultTokenRatesControllerState = exports.controllerName = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
@@ -96,10 +96,7 @@ class TokenRatesController extends (0, polling_controller_1.StaticIntervalPollin
         _TokenRatesController_pollState.set(this, PollState.Inactive);
         _TokenRatesController_tokenPricesService.set(this, void 0);
         _TokenRatesController_inProcessExchangeRateUpdates.set(this, {});
-        _TokenRatesController_selectedAccountId.set(this, void 0);
         _TokenRatesController_disabled.set(this, void 0);
-        _TokenRatesController_chainId.set(this, void 0);
-        _TokenRatesController_ticker.set(this, void 0);
         _TokenRatesController_interval.set(this, void 0);
         _TokenRatesController_allTokens.set(this, void 0);
         _TokenRatesController_allDetectedTokens.set(this, void 0);
@@ -107,10 +104,6 @@ class TokenRatesController extends (0, polling_controller_1.StaticIntervalPollin
         __classPrivateFieldSet(this, _TokenRatesController_tokenPricesService, tokenPricesService, "f");
         __classPrivateFieldSet(this, _TokenRatesController_disabled, disabled, "f");
         __classPrivateFieldSet(this, _TokenRatesController_interval, interval, "f");
-        const { chainId: currentChainId, ticker: currentTicker } = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getChainIdAndTicker).call(this);
-        __classPrivateFieldSet(this, _TokenRatesController_chainId, currentChainId, "f");
-        __classPrivateFieldSet(this, _TokenRatesController_ticker, currentTicker, "f");
-        __classPrivateFieldSet(this, _TokenRatesController_selectedAccountId, __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getSelectedAccount).call(this).id, "f");
         const { allTokens, allDetectedTokens } = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokensControllerState).call(this);
         __classPrivateFieldSet(this, _TokenRatesController_allTokens, allTokens, "f");
         __classPrivateFieldSet(this, _TokenRatesController_allDetectedTokens, allDetectedTokens, "f");
@@ -131,11 +124,14 @@ class TokenRatesController extends (0, polling_controller_1.StaticIntervalPollin
     }
     /**
      * Start (or restart) polling.
+     *
+     * @param chainId - The chain ID.
+     * @param nativeCurrency - The native currency.
      */
-    async start() {
+    async start(chainId, nativeCurrency) {
         __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
         __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Active, "f");
-        await __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
+        await __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this, chainId, nativeCurrency);
     }
     /**
      * Stop polling.
@@ -146,83 +142,91 @@ class TokenRatesController extends (0, polling_controller_1.StaticIntervalPollin
     }
     /**
      * Updates exchange rates for all tokens.
+     *
+     * @param chainIdAndNativeCurrency - The chain ID and native currency.
      */
-    async updateExchangeRates() {
-        await this.updateExchangeRatesByChainId({
-            chainId: __classPrivateFieldGet(this, _TokenRatesController_chainId, "f"),
-            nativeCurrency: __classPrivateFieldGet(this, _TokenRatesController_ticker, "f"),
-        });
+    async updateExchangeRates(chainIdAndNativeCurrency) {
+        await this.updateExchangeRatesByChainId(chainIdAndNativeCurrency);
     }
     /**
      * Updates exchange rates for all tokens.
      *
-     * @param options - The options to fetch exchange rates.
-     * @param options.chainId - The chain ID.
-     * @param options.nativeCurrency - The ticker for the chain.
+     * @param chainIds - The chain IDs.
+     * @returns A promise that resolves when all chain updates complete.
+     */
+    /**
+     * Updates exchange rates for all tokens.
+     *
+     * @param chainIdAndNativeCurrency - The chain ID and native currency.
      */
-    async updateExchangeRatesByChainId({ chainId, nativeCurrency, }) {
+    async updateExchangeRatesByChainId(chainIdAndNativeCurrency) {
         if (__classPrivateFieldGet(this, _TokenRatesController_disabled, "f")) {
             return;
         }
-        const tokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, chainId);
-        // Key dependencies that will trigger a new request instead of aborting:
-        // - chainId - different chains require a new request
-        // - nativeCurrency - changing native currency requires fetching different rates
-        // - tokenAddress length - if we have detected any new tokens, we will need to make a new request for the rates
-        const updateKey = `${chainId}:${nativeCurrency}:${tokenAddresses.length}`;
-        if (updateKey in __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")) {
-            // This prevents redundant updates
-            // This promise is resolved after the in-progress update has finished,
-            // and state has been updated.
-            await __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
-            return;
-        }
-        const { promise: inProgressUpdate, resolve: updateSucceeded, reject: updateFailed, } = (0, utils_1.createDeferredPromise)({ suppressUnhandledRejection: true });
-        __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey] = inProgressUpdate;
-        try {
-            const contractInformations = await __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRates).call(this, {
-                tokenAddresses,
-                chainId,
-                nativeCurrency,
-            });
-            const marketData = {
-                [chainId]: {
-                    ...(contractInformations ?? {}),
-                },
-            };
+        // Create a promise for each chainId to fetch exchange rates.
+        const updatePromises = chainIdAndNativeCurrency.map(async ({ chainId, nativeCurrency }) => {
+            const tokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, chainId);
+            // Build a unique key based on chainId, nativeCurrency, and the number of token addresses.
+            const updateKey = `${chainId}:${nativeCurrency}:${tokenAddresses.length}`;
+            if (updateKey in __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")) {
+                // Await any ongoing update to avoid redundant work.
+                await __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
+                return null;
+            }
+            // Create a deferred promise to track this update.
+            const { promise: inProgressUpdate, resolve: updateSucceeded, reject: updateFailed, } = (0, utils_1.createDeferredPromise)({ suppressUnhandledRejection: true });
+            __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey] = inProgressUpdate;
+            try {
+                const contractInformations = await __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRates).call(this, {
+                    tokenAddresses,
+                    chainId,
+                    nativeCurrency,
+                });
+                // Each promise returns an object with the market data for the chain.
+                const marketData = {
+                    [chainId]: {
+                        ...(contractInformations ?? {}),
+                    },
+                };
+                updateSucceeded();
+                return marketData;
+            }
+            catch (error) {
+                updateFailed(error);
+                throw error;
+            }
+            finally {
+                // Cleanup the tracking for this update.
+                delete __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
+            }
+        });
+        // Wait for all update promises to settle.
+        const results = await Promise.allSettled(updatePromises);
+        // Merge all successful market data updates into one object.
+        const combinedMarketData = results.reduce((acc, result) => {
+            if (result.status === 'fulfilled' && result.value) {
+                acc = { ...acc, ...result.value };
+            }
+            return acc;
+        }, {});
+        // Call this.update only once with the combined market data to reduce the number of state changes and re-renders
+        if (Object.keys(combinedMarketData).length > 0) {
             this.update((state) => {
                 state.marketData = {
                     ...state.marketData,
-                    ...marketData,
+                    ...combinedMarketData,
                 };
             });
-            updateSucceeded();
-        }
-        catch (error) {
-            updateFailed(error);
-            throw error;
-        }
-        finally {
-            delete __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
         }
     }
     /**
      * Updates token rates for the given networkClientId
      *
      * @param input - The input for the poll.
-     * @param input.chainId - The chain id to poll token rates on.
+     * @param input.chainIdAndNativeCurrency - The chain ids and native currencies to poll token rates on.
      */
-    async _executePoll({ chainId }) {
-        const { networkConfigurationsByChainId } = this.messagingSystem.call('NetworkController:getState');
-        const networkConfiguration = networkConfigurationsByChainId[chainId];
-        if (!networkConfiguration) {
-            console.error(`TokenRatesController: No network configuration found for chainId ${chainId}`);
-            return;
-        }
-        await this.updateExchangeRatesByChainId({
-            chainId,
-            nativeCurrency: networkConfiguration.nativeCurrency,
-        });
+    async _executePoll({ chainIdAndNativeCurrency, }) {
+        await this.updateExchangeRatesByChainId(chainIdAndNativeCurrency);
     }
     /**
      * Reset the controller state to the default state.
@@ -234,7 +238,7 @@ class TokenRatesController extends (0, polling_controller_1.StaticIntervalPollin
     }
 }
 exports.TokenRatesController = TokenRatesController;
-_TokenRatesController_handle = new WeakMap(), _TokenRatesController_pollState = new WeakMap(), _TokenRatesController_tokenPricesService = new WeakMap(), _TokenRatesController_inProcessExchangeRateUpdates = new WeakMap(), _TokenRatesController_selectedAccountId = new WeakMap(), _TokenRatesController_disabled = new WeakMap(), _TokenRatesController_chainId = new WeakMap(), _TokenRatesController_ticker = new WeakMap(), _TokenRatesController_interval = new WeakMap(), _TokenRatesController_allTokens = new WeakMap(), _TokenRatesController_allDetectedTokens = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_subscribeToTokensStateChange = function _TokenRatesController_subscribeToTokensStateChange() {
+_TokenRatesController_handle = new WeakMap(), _TokenRatesController_pollState = new WeakMap(), _TokenRatesController_tokenPricesService = new WeakMap(), _TokenRatesController_inProcessExchangeRateUpdates = new WeakMap(), _TokenRatesController_disabled = new WeakMap(), _TokenRatesController_interval = new WeakMap(), _TokenRatesController_allTokens = new WeakMap(), _TokenRatesController_allDetectedTokens = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_subscribeToTokensStateChange = function _TokenRatesController_subscribeToTokensStateChange() {
     this.messagingSystem.subscribe('TokensController:stateChange', 
     // TODO: Either fix this lint violation or explain why it's necessary to ignore.
     // eslint-disable-next-line @typescript-eslint/no-misused-promises
@@ -242,6 +246,7 @@ _TokenRatesController_handle = new WeakMap(), _TokenRatesController_pollState =
         if (__classPrivateFieldGet(this, _TokenRatesController_disabled, "f")) {
             return;
         }
+        const { networkConfigurationsByChainId } = this.messagingSystem.call('NetworkController:getState');
         const chainIds = [
             ...new Set([
                 ...Object.keys(allTokens),
@@ -252,16 +257,13 @@ _TokenRatesController_handle = new WeakMap(), _TokenRatesController_pollState =
             !(0, lodash_1.isEqual)(__classPrivateFieldGet(this, _TokenRatesController_allDetectedTokens, "f")[chainId], allDetectedTokens[chainId]));
         __classPrivateFieldSet(this, _TokenRatesController_allTokens, allTokens, "f");
         __classPrivateFieldSet(this, _TokenRatesController_allDetectedTokens, allDetectedTokens, "f");
-        const { networkConfigurationsByChainId } = this.messagingSystem.call('NetworkController:getState');
-        await Promise.allSettled(chainIdsToUpdate.map(async (chainId) => {
-            const nativeCurrency = networkConfigurationsByChainId[chainId]?.nativeCurrency;
-            if (nativeCurrency) {
-                await this.updateExchangeRatesByChainId({
-                    chainId: chainId,
-                    nativeCurrency,
-                });
-            }
-        }));
+        const chainIdAndNativeCurrency = chainIdsToUpdate.map((chainId) => {
+            return {
+                chainId: chainId,
+                nativeCurrency: networkConfigurationsByChainId[chainId]?.nativeCurrency,
+            };
+        });
+        await this.updateExchangeRatesByChainId(chainIdAndNativeCurrency);
     }, ({ allTokens, allDetectedTokens }) => {
         return { allTokens, allDetectedTokens };
     });
@@ -269,14 +271,15 @@ _TokenRatesController_handle = new WeakMap(), _TokenRatesController_pollState =
     this.messagingSystem.subscribe('NetworkController:stateChange', 
     // TODO: Either fix this lint violation or explain why it's necessary to ignore.
     // eslint-disable-next-line @typescript-eslint/no-misused-promises
-    async ({ selectedNetworkClientId }, patches) => {
-        const { configuration: { chainId, ticker }, } = this.messagingSystem.call('NetworkController:getNetworkClientById', selectedNetworkClientId);
-        if (__classPrivateFieldGet(this, _TokenRatesController_chainId, "f") !== chainId || __classPrivateFieldGet(this, _TokenRatesController_ticker, "f") !== ticker) {
-            __classPrivateFieldSet(this, _TokenRatesController_chainId, chainId, "f");
-            __classPrivateFieldSet(this, _TokenRatesController_ticker, ticker, "f");
-            if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
-                await this.updateExchangeRates();
-            }
+    async ({ networkConfigurationsByChainId }, patches) => {
+        const chainIdAndNativeCurrency = Object.values(networkConfigurationsByChainId).map(({ chainId, nativeCurrency }) => {
+            return {
+                chainId: chainId,
+                nativeCurrency,
+            };
+        });
+        if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
+            await this.updateExchangeRates(chainIdAndNativeCurrency);
         }
         // Remove state for deleted networks
         for (const patch of patches) {
@@ -294,16 +297,6 @@ _TokenRatesController_handle = new WeakMap(), _TokenRatesController_pollState =
     const tokenAddresses = getTokens(__classPrivateFieldGet(this, _TokenRatesController_allTokens, "f")[chainId]);
     const detectedTokenAddresses = getTokens(__classPrivateFieldGet(this, _TokenRatesController_allDetectedTokens, "f")[chainId]);
     return [...new Set([...tokenAddresses, ...detectedTokenAddresses])].sort();
-}, _TokenRatesController_getSelectedAccount = function _TokenRatesController_getSelectedAccount() {
-    const selectedAccount = this.messagingSystem.call('AccountsController:getSelectedAccount');
-    return selectedAccount;
-}, _TokenRatesController_getChainIdAndTicker = function _TokenRatesController_getChainIdAndTicker() {
-    const { selectedNetworkClientId } = this.messagingSystem.call('NetworkController:getState');
-    const networkClient = this.messagingSystem.call('NetworkController:getNetworkClientById', selectedNetworkClientId);
-    return {
-        chainId: networkClient.configuration.chainId,
-        ticker: networkClient.configuration.ticker,
-    };
 }, _TokenRatesController_getTokensControllerState = function _TokenRatesController_getTokensControllerState() {
     const { allTokens, allDetectedTokens } = this.messagingSystem.call('TokensController:getState');
     return {
@@ -317,15 +310,18 @@ _TokenRatesController_handle = new WeakMap(), _TokenRatesController_pollState =
 }, _TokenRatesController_poll = 
 /**
  * Poll for exchange rate updates.
+ *
+ * @param chainId - The chain ID.
+ * @param nativeCurrency - The native currency.
  */
-async function _TokenRatesController_poll() {
-    await (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
+async function _TokenRatesController_poll(chainId, nativeCurrency) {
+    await (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates([{ chainId, nativeCurrency }]));
     // Poll using recursive `setTimeout` instead of `setInterval` so that
     // requests don't stack if they take longer than the polling interval
     __classPrivateFieldSet(this, _TokenRatesController_handle, setTimeout(() => {
         // TODO: Either fix this lint violation or explain why it's necessary to ignore.
         // eslint-disable-next-line @typescript-eslint/no-floating-promises
-        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
+        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this, chainId, nativeCurrency);
     }, __classPrivateFieldGet(this, _TokenRatesController_interval, "f")), "f");
 }, _TokenRatesController_fetchAndMapExchangeRates = 
 /**
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.cts b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.cts
index f9c0b69..de6abe3 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.cts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.cts
@@ -105,7 +105,7 @@ export type TokenRatesControllerMessenger = RestrictedMessenger<typeof controlle
 export declare const getDefaultTokenRatesControllerState: () => TokenRatesControllerState;
 /** The input to start polling for the {@link TokenRatesController} */
 export type TokenRatesPollingInput = {
-    chainId: Hex;
+    chainIds: Hex[];
 };
 declare const TokenRatesController_base: (abstract new (...args: any[]) => {
     readonly "__#14@#intervalIds": Record<string, NodeJS.Timeout>;
@@ -155,34 +155,46 @@ export declare class TokenRatesController extends TokenRatesController_base<type
     disable(): void;
     /**
      * Start (or restart) polling.
+     *
+     * @param chainId - The chain ID.
+     * @param nativeCurrency - The native currency.
      */
-    start(): Promise<void>;
+    start(chainId: Hex, nativeCurrency: string): Promise<void>;
     /**
      * Stop polling.
      */
     stop(): void;
     /**
      * Updates exchange rates for all tokens.
+     *
+     * @param chainIdAndNativeCurrency - The chain ID and native currency.
+     */
+    updateExchangeRates(chainIdAndNativeCurrency: {
+        chainId: Hex;
+        nativeCurrency: string;
+    }[]): Promise<void>;
+    /**
+     * Updates exchange rates for all tokens.
+     *
+     * @param chainIds - The chain IDs.
+     * @returns A promise that resolves when all chain updates complete.
      */
-    updateExchangeRates(): Promise<void>;
     /**
      * Updates exchange rates for all tokens.
      *
-     * @param options - The options to fetch exchange rates.
-     * @param options.chainId - The chain ID.
-     * @param options.nativeCurrency - The ticker for the chain.
+     * @param chainIdAndNativeCurrency - The chain ID and native currency.
      */
-    updateExchangeRatesByChainId({ chainId, nativeCurrency, }: {
+    updateExchangeRatesByChainId(chainIdAndNativeCurrency: {
         chainId: Hex;
         nativeCurrency: string;
-    }): Promise<void>;
+    }[]): Promise<void>;
     /**
      * Updates token rates for the given networkClientId
      *
      * @param input - The input for the poll.
-     * @param input.chainId - The chain id to poll token rates on.
+     * @param input.chainIds - The chain ids to poll token rates on.
      */
-    _executePoll({ chainId }: TokenRatesPollingInput): Promise<void>;
+    _executePoll({ chainIds }: TokenRatesPollingInput): Promise<void>;
     /**
      * Reset the controller state to the default state.
      */
