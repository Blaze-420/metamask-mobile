diff --git a/node_modules/@metamask/keyring-controller/dist/KeyringController.cjs b/node_modules/@metamask/keyring-controller/dist/KeyringController.cjs
index b36fab7..8291d34 100644
--- a/node_modules/@metamask/keyring-controller/dist/KeyringController.cjs
+++ b/node_modules/@metamask/keyring-controller/dist/KeyringController.cjs
@@ -1322,8 +1322,15 @@ async function _KeyringController_unlockKeyrings(password, encryptionKey, encryp
                 const result = await __classPrivateFieldGet(this, _KeyringController_encryptor, "f").decryptWithDetail(password, encryptedVault);
                 vault = result.vault;
                 __classPrivateFieldSet(this, _KeyringController_password, password, "f");
-                updatedState.encryptionKey = result.exportedKeyString;
-                updatedState.encryptionSalt = result.salt;
+                // This condition is required to not set the state of the keyring
+                // with an encryption key and salt derived from with parameters
+                // that are not the ones set by the encrytor class.
+                if (!__classPrivateFieldGet(this, _KeyringController_encryptor, "f").isVaultUpdated ||
+                    __classPrivateFieldGet(this, _KeyringController_encryptor, "f").isVaultUpdated(encryptedVault)) {
+                    console.log('set stored encryption key and salt');
+                    updatedState.encryptionKey = result.exportedKeyString;
+                    updatedState.encryptionSalt = result.salt;
+                }
             }
             else {
                 const parsedEncryptedVault = JSON.parse(encryptedVault);
@@ -1377,18 +1384,19 @@ async function _KeyringController_unlockKeyrings(password, encryptionKey, encryp
     });
 }, _KeyringController_updateVault = function _KeyringController_updateVault() {
     return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_withVaultLock).call(this, async () => {
-        const { encryptionKey, encryptionSalt } = this.state;
+        const { encryptionKey, encryptionSalt, vault } = this.state;
+        const useCachedKey = encryptionKey && vault && __classPrivateFieldGet(this, _KeyringController_encryptor, "f").isVaultUpdated?.(vault);
         if (!__classPrivateFieldGet(this, _KeyringController_password, "f") && !encryptionKey) {
-            throw new Error(constants_1.KeyringControllerError.MissingCredentials);
+            throw new Error(KeyringControllerError.MissingCredentials);
         }
         const serializedKeyrings = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getSerializedKeyrings).call(this);
         if (!serializedKeyrings.some((keyring) => keyring.type === KeyringTypes.hd)) {
-            throw new Error(constants_1.KeyringControllerError.NoHdKeyring);
+            throw new Error(KeyringControllerError.NoHdKeyring);
         }
         const updatedState = {};
         if (__classPrivateFieldGet(this, _KeyringController_cacheEncryptionKey, "f")) {
             assertIsExportableKeyEncryptor(__classPrivateFieldGet(this, _KeyringController_encryptor, "f"));
-            if (encryptionKey) {
+            if (useCachedKey) {
                 const key = await __classPrivateFieldGet(this, _KeyringController_encryptor, "f").importKey(encryptionKey);
                 const vaultJSON = await __classPrivateFieldGet(this, _KeyringController_encryptor, "f").encryptWithKey(key, serializedKeyrings);
                 vaultJSON.salt = encryptionSalt;
@@ -1405,11 +1413,11 @@ async function _KeyringController_unlockKeyrings(password, encryptionKey, encryp
             updatedState.vault = await __classPrivateFieldGet(this, _KeyringController_encryptor, "f").encrypt(__classPrivateFieldGet(this, _KeyringController_password, "f"), serializedKeyrings);
         }
         if (!updatedState.vault) {
-            throw new Error(constants_1.KeyringControllerError.MissingVaultData);
+            throw new Error(KeyringControllerError.MissingVaultData);
         }
         const updatedKeyrings = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getUpdatedKeyrings).call(this);
         if (updatedKeyrings.length !== __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").length) {
-            throw new Error(constants_1.KeyringControllerError.KeyringMetadataLengthMismatch);
+            throw new Error(KeyringControllerError.KeyringMetadataLengthMismatch);
         }
         this.update((state) => {
             state.vault = updatedState.vault;
diff --git a/node_modules/@metamask/keyring-controller/dist/KeyringController.mjs b/node_modules/@metamask/keyring-controller/dist/KeyringController.mjs
index f5f526a..e8fccbe 100644
--- a/node_modules/@metamask/keyring-controller/dist/KeyringController.mjs
+++ b/node_modules/@metamask/keyring-controller/dist/KeyringController.mjs
@@ -1297,8 +1297,15 @@ async function _KeyringController_unlockKeyrings(password, encryptionKey, encryp
                 const result = await __classPrivateFieldGet(this, _KeyringController_encryptor, "f").decryptWithDetail(password, encryptedVault);
                 vault = result.vault;
                 __classPrivateFieldSet(this, _KeyringController_password, password, "f");
-                updatedState.encryptionKey = result.exportedKeyString;
-                updatedState.encryptionSalt = result.salt;
+                // This condition is required to not set the state of the keyring
+                // with an encryption key and salt derived from with parameters
+                // that are not the ones set by the encrytor class.
+                if (!__classPrivateFieldGet(this, _KeyringController_encryptor, "f").isVaultUpdated ||
+                    __classPrivateFieldGet(this, _KeyringController_encryptor, "f").isVaultUpdated(encryptedVault)) {
+                    console.log('set stored encryption key and salt');
+                    updatedState.encryptionKey = result.exportedKeyString;
+                    updatedState.encryptionSalt = result.salt;
+                }
             }
             else {
                 const parsedEncryptedVault = JSON.parse(encryptedVault);
@@ -1352,7 +1359,8 @@ async function _KeyringController_unlockKeyrings(password, encryptionKey, encryp
     });
 }, _KeyringController_updateVault = function _KeyringController_updateVault() {
     return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_withVaultLock).call(this, async () => {
-        const { encryptionKey, encryptionSalt } = this.state;
+        const { encryptionKey, encryptionSalt, vault } = this.state;
+        const useCachedKey = encryptionKey && vault && __classPrivateFieldGet(this, _KeyringController_encryptor, "f").isVaultUpdated?.(vault);
         if (!__classPrivateFieldGet(this, _KeyringController_password, "f") && !encryptionKey) {
             throw new Error(KeyringControllerError.MissingCredentials);
         }
@@ -1363,7 +1371,7 @@ async function _KeyringController_unlockKeyrings(password, encryptionKey, encryp
         const updatedState = {};
         if (__classPrivateFieldGet(this, _KeyringController_cacheEncryptionKey, "f")) {
             assertIsExportableKeyEncryptor(__classPrivateFieldGet(this, _KeyringController_encryptor, "f"));
-            if (encryptionKey) {
+            if (useCachedKey) {
                 const key = await __classPrivateFieldGet(this, _KeyringController_encryptor, "f").importKey(encryptionKey);
                 const vaultJSON = await __classPrivateFieldGet(this, _KeyringController_encryptor, "f").encryptWithKey(key, serializedKeyrings);
                 vaultJSON.salt = encryptionSalt;
